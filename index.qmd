---
title: "An√°lisis y visualizaci√≥n de datos con R"
subtitle: "Simulaci√≥n (IMAD743)"
title-slide-attributes:
  data-background-image: img/highcharts.jpg
  data-background-size: contain
  data-background-opacity: "0.40"
author: "Escuela Polit√©cnica Nacional"
affiliation: Escuela Polit√©cnica Nacional
lang: es
language: custom_lang.yml
format: 
  revealjs:
    theme: [default, style.scss]
    chalkboard: true
    multiplex: true
    menu:
      side: left
      width: normal
    footer: "[<strong>Diego Pa√∫l Huaraca S.</strong>](...) ‚Ä¢ Semestre 2023-A"
    slide-number: c/t
execute:
  echo: true
---

# ¬°Bienvenidos al curso de Simulaci√≥n!

[**Dejad Excel a un lado**]{style="color:#444442;"}  
![](img/hateExcel.png){width=10%}

---

## ¬°Hola a todos!

::: columns
::: {.column width="30%"}
![](img/me.jpeg)
:::

::: {.column width="70%"}
::: incremental
-   [**Diego Pa√∫l Huaraca Shag√±ay**]{.hl-yellow}, nacido en 1989 en Riobamba.

-   Ingeniero Matem√°tico. [**Escuela Polit√©cnica Nacional**]{.hl-yellow} (2013).

-   M√°ster en Ciencias Actuariales y Financieras. [**Universidad de Alcal√°**]{.hl-yellow} (2018).

-   Consultor Anal√≠tico de Riesgo Financiero. [**BI-SCIENCES**]{.hl-green} (desde 2018).

-   Docente del Departamento de Matem√°tica. [**Escuela Polit√©cnica Nacional**]{.hl-green} (desde 2018).

-   Consultor Actuarial. [**Superintendencia de Bancos**]{.hl-green} (desde 2022).
:::
:::
:::

---

## Contenido del curso 
<!-- Primera parte -->
::: columns
::: {.column width="20%"}
![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)
:::

::: {.column width="80%"}
::: incremental
-   [**Introducci√≥n al Lenguaje R**]{.hl-red} ‚Üí `{a programar se aprende programando}`.

-   [**Visualizaci√≥n de datos**]{.hl-red} ‚Üí `{gr√°ficos est√°ticos y din√°micos}`.

-   [**Desarrollo de aplicativos web**]{.hl-red} ‚Üí `{shiny, shinydashboard}`.

-   [**Reporter√≠a din√°mica**]{.hl-red} ‚Üí `{LaTeX, rmarkdown, Quarto}`.

-   [**Simuladores de n√∫meros aleatorios**]{.hl-yellow}  ‚Üí `{base}`.

-   [**Simulaci√≥n de variables aleatorias**]{.hl-yellow} ‚Üí `{discretas y continuas}`.
:::
:::
:::


## Contenido del curso
<!-- Segunda Parte -->
::: columns
::: {.column width="20%"}
![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTPKIAIbhuhpU6GMjL2jBdHycULZOCEVt-XWs9Z_b0elEikNTefOLW3yk2ajknsTLsMDo4&usqp=CAU)
:::

::: {.column width="80%"}
::: incremental
-   [**Simulaci√≥n de vectores aleatorias**]{.hl-yellow}.

-   [**Simulaci√≥n de procesos estoc√°sticos**]{.hl-yellow} ‚Üí `{Markov, Weiner, etc.}`.

-   [**M√©todos de MonteCarlo**]{.hl-red} ‚Üí `{secuenciales, inferencia estad√≠stica}`.

-   [**T√©cnicas de Remuestreo**]{.hl-red}.

-   [**M√©todos de MoteCarlo en Cadenas de Markov**]{.hl-red}

-   [**Aplicaciones avanzadas**]{.hl-red} ‚Üí `{simulaci√≥n por eventos}`.
:::
:::
:::


# Instalaci√≥n del Lenguaje R

[**Instalando R y RStudio**]{style="color:#444442;"}

---

## Requisitos

Para el desarrollo del curso se requiere:

1.  [**Conexi√≥n a internet**]{.hl-yellow} (para la descarga de paquetes y bases de datos).

2.  [**Descargar R**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://cran.r-project.org/>

3.  [**Descargar RStudio**]{.hl-yellow}: La descarga se realiza (gratuitamente) desde el enlace: <https://posit.co/download/rstudio-desktop/>

::: columns
::: {.column width="50%"}
![](img/cranR.jpg){width="440"}
:::

::: {.column width="50%"}
![](img/rstudio.jpg){width="440"}
:::
:::

---

## Instalaci√≥n de R

::: incremental
-   [**Paso 1**]{.hl-yellow}: Ingrese al repositorio CRAN en [**https://cran.r-project.org/**](https://cran.r-project.org/){.uri} y seleccione su sistema operativo.

-   [**Paso 2**]{.hl-yellow}: Para el sistema MacOs basta con hacer click en **R-4.X.Y.pkg**, y abrirlo una vez descargado. Para el sistema Windows, basta con hacer click en **install R for the first time** y despu√©s en **Download R-X.Y.Z for Windows**, una vez descargado, abrirlo como cualquier archivo de instalaci√≥n.

-   [**Paso 3**]{.hl-yellow}: Abrir el ejecutable e instalar el programa con todas las opciones por defecto.
:::

. . .

::: callout-important
Siempre que tengas que descargar algo del repositorio CRAN (ya sea el propio R o un paquete), [**aseg√∫rate de tener conexi√≥n a internet**]{.hl-red}.
:::

---

## CRAN

::: incremental
- El lenguaje R se distribuye gratuitamente a trav√©s del repositorio [**Comprehensive R Archive Network (CRAN)**]{.hl-purple}  propiedad de la R Foundation for Statistical Computing.

- El mantenimiento se encuentra a cargo del [**grupo R Core Team**]{.hl-purple} asistido por una gran cantidad de colaboradores internacionales.

- Con la finalidad de evitar el colapso del mundo estad√≠stico, el repositorio CRAN se refleja en [**diferentes lugares**]{.hl-purple} de todo el mundo
:::


::: {.column width="60%"}
![](img/CRAN.png){width="380"}
:::

---

## Funcionamiento

::: incremental
- R es un lenguaje [**orientado a objetos**]{.hl-purple} dise√±ado en un entorno aut√©ntico bajo el cual esconde su simplicidad y flexibilidad, lo cual permite a sus usuarios a√±adir funcionalidad mediante la definici√≥n de nuevas funciones y operadores.

- R almacena sus variables, datos, funciones y resultados en la [**memoria activa**]{.hl-purple} del computador en forma de objetos con un nombre espec√≠fico y pueden ser [**modificados o manipulados**]{.hl-purple} por el usuario.
:::

::: {.column width="90%"}
![](img/FunR.png){width="630"}
:::


---

## Primera operaci√≥n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.

Esa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="240"}
:::
:::

. . .

[**Idea**]{.hl-yellow}: a una variable llamada `a` le asignaremos el valor de `3` (escribiremos el c√≥digo de abajo en la consola y daremos ¬´enter¬ª)

```{r}
#| code-line-numbers: "1"
a <- 3
```

---

## Primera operaci√≥n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.

Esa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="240"}
:::
:::

[**Idea**]{.hl-yellow}: definiremos otra variable llamada `b` y le asignaremos el valor `5`

```{r}
#| code-line-numbers: "2"
a <- 3
b <- 5
```

. . .

::: callout-note
## F√≠jate que...

En `R` usaremos `<-` como una **flecha**: la variable a la izquierda de dicha flecha recibe el valor que hay a la derecha (por ejemplo, `a <- 3`)
:::

---

## Primera operaci√≥n

::: columns
::: {.column width="65%"}
Para comprobar que se ha instalado correctamente, tras abrir `R`, deber√≠as ver una **pantalla blanca** similar a esta.

Esa ¬´pantalla blanca¬ª se llama [**consola**]{.hl-yellow} y podemos hacer un primer uso de ella como si se tratase de una **calculadora**.
:::

::: {.column width="35%"}
![](img/consola.jpg){width="240"}
:::
:::

[**Idea**]{.hl-yellow}: haremos la suma `a + b` y nos devolver√° su resultado

```{r}
#| code-line-numbers: "3"
a <- 3
b <- 5
a + b
```

---

## Instalaci√≥n de RStudio

`RStudio` ser√° el [**Bloc de Notas**]{.hl-purple} que usaremos para escribir los c√≥digos (lo que se conoce como un [**IDE: entorno integrado de desarrollo**]{.hl-yellow}).

::: incremental
-   [**Paso 1**]{.hl-yellow}: Ingrese a la p√°gina de Posit en [**https://posit.co/download/rstudio-desktop/**](https://posit.co/download/rstudio-desktop/){.uri} y seleccione la descarga gratuita.

-   [**Paso 2**]{.hl-yellow}: Selecciona el ejecutable en funci√≥n al sistema operativo que use.

-   [**Paso 3**]{.hl-yellow}: Luego de la descarga, se apertura el ejecutable como cualquier otro programa y se instala todo por defecto.
:::

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Consola**]{.hl-yellow}: es el nombre para llamar a la ventana grande que te ocupa buena parte de tu pantalla. Prueba a escribir el mismo c√≥digo que antes (la suma de las variables) en ella. La consola ser√° donde [**ejecutaremos √≥rdenes y mostraremos resultados**]{.hl-purple}.

![](img/consola_rstudio.jpg){width="420"}

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Environment**]{.hl-yellow}: la pantalla peque√±a (puedes ajustar los m√°rgenes con el rat√≥n a tu gusto) que tenemos en la parte superior derecha. Nos mostrar√° las [**variables que tenemos definidas**]{.hl-purple}.

![](img/environment.jpg){width="420"}

---

## Organizaci√≥n de RStudio

Al abrir `RStudio` seguramente tengas tres ventanas:

-   [**Panel multiusos**]{.hl-yellow}: la ventana que tenemos en la parte inferior derecha servir√° para buscar [**ayuda de funciones**]{.hl-purple}, para [**visualizar gr√°ficos**]{.hl-purple}, as√≠ como para la [**carga de librer√≠as**]{.hl-purple} y [**navegaci√≥n**]{.hl-purple} por las carpetas del CPU.

![](img/multiusos.jpg){width="420"}

# ¬øQu√© es R? Primeros usos

[**¬øCu√°les son las ventajas? Primer uso**]{style="color:#444442;"}

---

## ¬øQu√© es R? ¬øPor qu√© R?

![](img/meme_barco.jpg)

---

## ¬øQu√© es R? ¬øPor qu√© R?

`R` es el [**lenguaje estad√≠stico por excelencia**]{.hl-yellow}, creado por y para estad√≠sticos/as, con 5 ventajas fundamentales [**frente a Excel**]{.hl-red}:


::: incremental
-   [**Lenguaje de programaci√≥n**]{.hl-yellow}: la obviedad [‚Üí an√°lisis [**replicables**]{.hl-purple}]{.fragment .fade-in}

-   [**Gratuito**]{.hl-yellow}: la filosof√≠a de la comunidad de `R` es el compartir c√≥digo bajo **copyleft** [‚Üí [**uso √©tico de dinero p√∫blico**]{.hl-purple}]{.fragment .fade-in}

-   [**Software libre**]{.hl-yellow}: no solo es gratis sino que permite acceder libremente a c√≥digo ajeno, incluso al **propio c√≥digo fuente** [‚Üí [**flexibilidad y transparencia**]{.hl-purple}]{.fragment .fade-in}

-   [**Lenguaje modular**]{.hl-yellow}: hemos instalado lo m√≠nimo, pero existen c√≥digos de otras personas que podemos reusar (19430 [**paquetes**]{.hl-yellow} al 28/04/2023) [‚Üí [**ahorro de tiempo**]{.hl-purple}]{.fragment .fade-in}

-   [**Lenguaje de alto nivel**]{.hl-yellow}: facilita la programaci√≥n (como Python) [‚Üí [**menor curva de aprendizaje**]{.hl-purple}]{.fragment .fade-in}
:::


## ¬øPor qu√© programar?

-   [**Automatizar**]{.hl-yellow} ‚Üí te permitir√° automatizar tareas recurrentes (ejemplo: actualizar pron√≥sticos del tiempo, actualizar informes estad√≠sticos) de forma que solo tendr√°s que programarlo uno vez.

-   [**Replicabilidad**]{.hl-yellow} ‚Üí podr√°s replicar tu an√°lisis siempre de la misma manera.

-   [**Flexibilidad**]{.hl-yellow} ‚Üí podr√°s adaptar el software a tus necesidades.

-   [**Transparencia**]{.hl-yellow} ‚Üí ser auditado por la comunidad.

![](img/the_general_problem.png)

---

## Idea fundamental: paquetes

Una de las ideas claves de `R` es el [**uso de paquetes**]{.hl-yellow}: c√≥digos que otras personas han implementado para **resolver un problema**

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
::: {.fragment fragment-index="1"}
-   [**Instalaci√≥n**]{.hl-yellow}: descargamos los c√≥digos de la web (necesitamos internet) ‚Üí [**comprar un libro**]{.hl-purple}, solo una vez (por ordenador)

```{r}
#| eval: false
install.packages("ggplot2")
```
:::

::: {.fragment fragment-index="2"}
-   [**Carga**]{.hl-yellow}: indicamos qu√© paquetes queremos usar cada vez que iniciamos `RStudio` ‚Üí [**traer el libro de la estanter√≠a**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::
:::
:::

---

## Idea fundamental: paquetes

::: columns
::: {.column width="35%"}
![](img/paquetes.png)
:::

::: {.column width="65%"}
Una vez instalado, hay dos manera de usar un paquete (traerlo de la estanter√≠a)

::: {.fragment fragment-index="1"}
-   [**Paquete entero**]{.hl-yellow}: con `library()`, usando el nombre del paquete sin comillas, cargamos en la sesi√≥n [**todo el libro**]{.hl-purple}

```{r}
#| eval: false
library(ggplot2)
```
:::

::: {.fragment fragment-index="2"}
-   [**Funciones concretas**]{.hl-yellow} usando `paquete::funcion` le √≠ndicamos que solo queremos una [**p√°gina concreta de ese libro**]{.hl-purple}

```{r}
#| eval: false
ggplot2::geom_point()
```
:::
:::
:::

---

## Te vas equivocar

Durante tu aprendizaje va a ser muy habitual que las cosas no salgan a la primera ‚Üí [**te vas equivocar**]{.hl-yellow}. No solo ser√° importante asumirlo sino que es [**importante leer los mensajes de error**]{.hl-yellow} para aprender de ellos.

. . .

-   [**Mensajes de error**]{.hl-red}: precedidos de **¬´Error in...¬ª** y ser√°n aquellos fallos que [**impidan la ejecuci√≥n**]{.hl-yellow}

```{r}
#| error: true
"a" + 1 
```

. . .

-   [**Mensajes de warning**]{.hl-orange}: precedidos de **¬´Warning in...¬ª** son los (posibles) fallos m√°s delicados ya que son incoherencias que [**no impiden la ejecuci√≥n**]{.hl-yellow}

```{r}
#| warning: true
# Ejecuta la orden pero el resultado es NaN, **Not A Number**, un valor que no existe
sqrt(-1)
```

---

## Antes de arrancar: scripts

::: columns
::: {.column width="35%"}
![](img/abrir_script.jpg){width="350"}
:::

::: {.column width="65%"}
Un [**script**]{.hl-yellow} ser√° el documento en el que programamos, nuestro archivo `.doc` (aqu√≠ con extensi√≥n `.R`) donde escribiremos las √≥rdenes. Para **abrir nuestro primero script**, haz click en el men√∫ en `File < New File < R Script`.
:::
:::

::: callout-warning
## Cuidado

Es importante **no abusar de la consola**: todo lo que no escribas en un script, cuando cierres, [**lo habr√°s perdido**]{.hl-red}.
:::

---

## Ejecutando el primer script

Ahora tenemos una **cuarta ventana**: la ventana donde [**escribiremos nuestros c√≥digos**]{.hl-yellow}. ¬øC√≥mo ejecutarlo?

. . .

1.  **Escribimos** el c√≥digo a ejecutar.

. . .

2.  **Guardamos** el archivo .R haciendo click en `Save current document`.

. . .

3.  El c√≥digo no se ejecuta salvo que se lo indiquemos. Tenemos tres opciones:

-   [**Copiar y pegar**]{.hl-yellow} en consola.
-   [**Seleccionar l√≠neas**]{.hl-yellow} y `Ctrl+Enter`
-   [**Activar Source on save**]{.hl-yellow} a la derecha de guardar: no solo guarda sino que ejecuta el c√≥digo **completo**.

---

## üíª Tu turno

[**Ejecuta tu primer script**: crea un script de cero, programa lo indicado debajo y ejec√∫talo (de las 3 maneras posibles)]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define una variable de nombre `a` y cuyo valor sea -1

```{r}
#| code-fold: true
a <- -1
```

### [**Ejercicio 2**]{.hl-yellow}

üìù A√±ade debajo otra l√≠nea para definir una variable `b` con el valor 5. Tras ello m√∫ltiplica ambas variables

```{r}
#| code-fold: true
#| eval: false
b <- 5
a * b # sin guardar
multiplicacion <- a * b # guardado
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Modifica el c√≥digo inferior para definir dos variables c y d, con valores 3 y -1. Tras ello divide las variables.

```{r}
#| eval: false
c <- # deber√≠as asignarle el valor 3
d <- # deber√≠as asignarle el valor -1
```

```{r}
#| code-fold: true
#| eval: false
c <- 3
d <- -1
c / d # sin guardar
division <- c / d # guardado
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Asigna un valor positivo a `x` y calcula su ra√≠z cuadrada; asigna otro negativo `y` y calcula su valor absoluto con la funci√≥n `abs()`.

```{r}
#| code-fold: true
#| eval: false
x <- 5
sqrt(x)

y <- -2
abs(y)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Usando la variable `x` ya definida, completa/modifica el c√≥digo inferior para guardar en una nueva variable `z` el resultado guardado en `x` menos 5.

```{r}
#| eval: false
z <- ? - ? # completa el c√≥digo
z
```

```{r}
#| code-fold: true
#| eval: false
z <- x - 5
z
```
:::

::: callout-note
## Toma nota

Comandos como `sqrt()`, `abs()` o `max()` son lo que llamamos [**funciones**]{.hl-purple}: l√≠neas de c√≥digo que hemos ¬´encapsulado¬ª bajo un nombre, y dado unos argumentos de entrada, ejecuta las √≥rdenes (una especie de atajo).
:::

# Primeros datos: variables

[**¬øQu√© tipos de datos existen?**]{style="color:#444442;"}

---

## De la CELDA a la TABLA

¬øQu√© [**tipo de dato**]{.hl-yellow} podemos tener en cada celda de una **tabla**?

![](img/celdas.jpg){fig-align="middle"}

::: incremental
-   [**Celda**]{.hl-yellow}: dato individual de un tipo concreto.
-   [**Variable**]{.hl-yellow}: **concatenaci√≥n** de valores del mismo tipo ([**vectores**]{.hl-purple}).
-   [**Matriz**]{.hl-yellow}: concatenaci√≥n de variables del **mismo tipo y longitud**.
-   [**Tabla**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo pero igual longitud**]{.hl-purple}
-   [**Lista**]{.hl-yellow}: concatenaci√≥n de variables de [**distinto tipo y distinta longitud**]{.hl-purple}
:::

---

## Celdas: tipos de datos

¬øExisten [**variables m√°s all√° de los n√∫meros**]{.hl-yellow}?

. . .

Piensa por ejemplo en los datos guardados de una persona:

::: {.fragment .fade-up}
-   La edad o el peso ser√° un [**n√∫mero**]{.hl-yellow}.

```{r}
edad <- 33
```
:::

::: {.fragment .fade-up}
-   Su nombre ser√° una cadena de [**texto (string o char)**]{.hl-yellow}.

```{r}
nombre <- "javi"
```
:::

::: {.fragment .fade-up}
-   A la pregunta ¬´¬øest√° usted soltero/a?¬ª la respuesta ser√° lo que llamamos una [**variable l√≥gica**]{.hl-yellow} (`TRUE` si est√° soltero/a o `FALSE` en otro caso).

```{r}
soltero <- TRUE
```
:::

::: {.fragment .fade-up}
-   Su fecha de nacimiento ser√° precisamente eso, una [**fecha**]{.hl-yellow}.
:::

---

## Variables num√©ricos

El dato m√°s sencillo (ya lo hemos usado) ser√°n las [**variables num√©ricas**]{.hl-yellow}

```{r}
#| eval: false
a <- 5
b <- 2
a + b
```

```{r}
#| echo: false
#| include: false
a <- 5
b <- 2
a + b
```

¬†

. . .

Para saber el tipo de una variable tenemos la funci√≥n `class()`

```{r}
class(a)
```

¬†

. . .

Con las variables num√©ricas podemos realizar las [**operaciones aritm√©ticas**]{.hl-yellow} de una calculadora: sumar (`+`), ra√≠z cuadrada (`sqrt()`), cuadrado (`^2`), etc.

```{r}
a^2
```

---

## Variables de texto

Imagina que adem√°s de la edad de una persona queremos guardar su nombre

```{r}
nombre <- "Javier"
class(nombre)
```

¬†

. . .

Las [**cadenas de texto**]{.hl-yellow} son un tipo con el que obviamente [**no podremos hacer operaciones**]{.hl-red} aritm√©ticas (s√≠ otras operaciones como pegar o localizar patrones).

```{r}
#| error: true
nombre + 1 # error al sumar n√∫mero a texto
```

¬†

. . .

::: callout-warning
## Recuerda que...

Las variables de tipo texto (character o stringr) van siempre [**entre comillas**]{.hl-orange}.
:::

---

## Primera funci√≥n: paste

Como hemos comentado, una [**funci√≥n**]{.hl-yellow} es un trozo de **c√≥digo encapsulado** bajo un nombre que depende de unos argumentos de entrada. Nuestra primera funci√≥n ser√° `paste()`: dadas dos cadenas de texto nos permite pegarlas.

```{r}
paste("Javier", "√Ålvarez")
```

¬†

. . .

F√≠jate que [**por defecto**]{.hl-yellow} nos pega las cadenas con un espacio, pero podemos a√±adir un [**argumento opcional**]{.hl-yellow} para indicarle el separador

```{r}
paste("Javier", "√Ålvarez", sep = "*")
```

---

## Primera funci√≥n: paste

::: columns
::: {.column width="50%"}
![](img/paste_help.jpg)
:::

::: {.column width="50%"}
¬øC√≥mo saber que argumentos tiene una funci√≥n? Escribiendo en consola `? paste` te aparecer√° una [**ayuda**]{.hl-yellow} en el panel multiusos.

En dicha ayuda podr√°s ver en su cabecera que argumentos ya tiene asignados por defecto la funci√≥n
:::
:::

. . .

Existe una funci√≥n similar llamada `paste0()` que pega por defecto con `sep = ""` (sin nada).

```{r}
paste0("Javier", "√Ålvarez")
```

---

## Primer paquete: glue

Una forma m√°s intuitiva de trabajar con textos es usar el paquete `{glue}`: lo primero que haremos ser√° ¬´comprar el libro¬ª (si nunca lo hemos hecho). Tras ello [**cargamos el paquete**]{.hl-yellow}

```{r}
#| eval: false
install.packages("glue") # solo la primra vez
library(glue)
```

```{r}
#| echo: false
library(glue)
```

. . .

Con dicho paquete podemos usar [**variables dentro de cadenas de texto**]{.hl-yellow}. Por ejemplo, ¬´la edad es de ... a√±os¬ª, donde la edad est√° guardada en una variable.

```{r}
edad <- 33
glue("La edad es de {edad} a√±os")
```

. . .

Dentro de las llaves tambi√©n podemos ejecutar operaciones

```{r}
unidades <- "d√≠as"
glue("La edad es de {edad * 365} {unidades}")
```

---

## Variables l√≥gicas

Una [**variable l√≥gica o binaria**]{.hl-yellow} es aquella que toma **dos valores**:

-   `TRUE`: [**verdadero**]{.hl-yellow} guardado internamente como un 1.
-   `FALSE`: [**falso**]{.hl-yellow} guardado internamente como un 0.
-   `NA`: [**dato ausente**]{.hl-yellow} son las siglas de *not available*.

```{r}
soltero <- TRUE # ¬øEs soltero? --> S√ç
class(soltero)
```

. . .

::: callout-important
## Importante

Las variables l√≥gicas [**NO son variables de texto**]{.hl-red}: `"TRUE"` es un texto, `TRUE` es un valor l√≥gico.

```{r}
#| error: true
TRUE + 1
"TRUE" + 1
```
:::

---

## Condiciones l√≥gicas

Los valores l√≥gicos suelen ser resultado de [**evaluar condiciones l√≥gicas**]{.hl-yellow}. Por ejemplo, imaginemos que queremos comprobar si una persona se llama Javi.

```{r}
nombre <- "Mar√≠a"
```

¬†

. . .

Con el [**operador l√≥gico**]{.hl-yellow} `==` preguntamos s√≠ a la izquierda es igual a la derecha

```{r}
nombre == "Javi"
```

. . .

Con su opuesto `!=` preguntamos si es distinto.

```{r}
nombre != "Javi"
```

. . .

::: callout-note
## F√≠jate que...

No es lo mismo `<-` (asignaci√≥n) que una [**comparaci√≥n l√≥gica**]{.hl-yellow} con `==` (estamos preguntando).
:::

---

## Condiciones l√≥gicas

Adem√°s de las comparaciones ¬´igual a¬ª frente ¬´distinto¬ª, tambi√©n comparaciones de orden como `<, <=, > o >=`.

¬†

**¬øTiene la persona menos de 32 a√±os?**

```{r}
edad <- 38
edad < 32 # ¬øEs la edad menor de 32 a√±os?
```

¬†

**¬øLa edad es mayor o igual que 38 a√±os?**

```{r}
edad >= 38
```

---

## Variables de fecha

Un tipo de datos muy especial: los [**datos de tipo fecha**]{.hl-yellow}.

```{r}
fecha_char <- "2021-04-21"
```

. . .

Parece una simple cadena de texto pero [**representa un instante en el tiempo**]{.hl-yellow}. ¬øQu√© deber√≠a suceder si [**sumamos un 1 a una fecha**]{.hl-purple}?

```{r}
#| error: true
fecha_char + 1
```

. . .

Las fechas [**no pueden ser texto**]{.hl-red}: debemos convertir la cadena de texto a fecha con `as_date()` del paquete `{lubridate}`

```{r}
library(lubridate) # instala si no lo has hecho
fecha <- as_date("2023-03-28")
fecha + 1
class(fecha)
```

---

## Variables de fecha

En dicho paquete tenemos funciones muy √∫tiles para [**manejar fechas**]{.hl-yellow}:

-   Con `today()` podemos obtener directamente la [**fecha actual**]{.hl-purple}.

```{r}
today()
```

. . .

-   Con `now()` podemos obtener la [**fecha y hora actual**]{.hl-purple}

```{r}
now()
```

. . .

-   Con `year()`, `month()` o `day()` podemos [**extraer el a√±o, mes y d√≠a**]{.hl-purple}

```{r}
fecha <- today()
year(fecha)
month(fecha)
```

---

## Res√∫menes de paquetes

![](img/lubridate.png)

::: callout-note
## Amplia contenido

Tienes un resumen en pdf de los paquetes m√°s importantes en la [**carpeta ¬´fichas paquetes¬ª**]{.hl-green}
:::

---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define una variable que guarde tu edad y otra con tu nombre

```{r}
#| code-fold: true
edad <- 33
nombre <- "Javi"
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Define otra variable que responda la pregunta ¬´¬øtengo hermanos?¬ª y otra con la fecha de tu nacimiento.

```{r}
#| code-fold: true
hermanos <- TRUE

library(lubridate)
fecha_nacimiento <- as_date("1989-09-10")
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Define otra variable con tus apellidos y junta con `glue()` las variables `nombre` y `apellidos` (una coma entre ellos) en una sola variable `nombre_completo`.

```{r}
#| code-fold: true
#| eval: false
apellidos <- "√Ålvarez Li√©bana"
glue("{nombre}, {apellidos}")
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Calcula los d√≠as que han pasado desde la fecha de tu nacimiento, haciendo la resta entre la fecha de hoy y la fecha de nacimiento definida en el ejercicio 2.

```{r}
#| code-fold: true
#| eval: false
today() - fecha_nacimiento
```
:::

# Primeros datos: vectores

[**¬øC√≥mo concatenamos valores? ¬øC√≥mo creamos una columna?**]{style="color:#444442;"}

---

## Vectores: concatenar

Cuando trabajamos con datos normalmente tendremos [**columnas que representan variables**]{.hl-yellow}: llamaremos [**vectores**]{.hl-yellow} a una [**concatenaci√≥n**]{.hl-purple} de variables del [**mismo tipo**]{.hl-purple}

¬†

. . .

La forma m√°s sencilla es con el comando `c()` (c de **concatenar**), y basta con introducir sus elementos entre par√©ntesis y separados por comas

```{r}
edades <- c(33, 27, 60, 61)
edades
```

¬†

. . .

::: callout-tip
Un n√∫mero individual `x <- 1` es en realidad un vector de longitud uno.
:::

---

## Vectores: concatenar

::: columns
::: {.column width="40%"}
![](img/edades_environment.jpg)
:::

::: {.column width="60%"}
Como ves ahora en el `environment` tenemos una **colecci√≥n de elementos** guardada

```{r}
edades
```
:::
:::

. . .

¬†

La [**longitud de un vector**]{.hl-yellow} se puede calcular con `length()`

```{r}
length(edades)
```

. . .

Tambi√©n podemos [**concatenar vectores**]{.hl-yellow}

```{r}
c(edades, edades, 8)
```

---

## Secuencias num√©ricas

En muchas ocasiones querremos crear [**secuencias num√©ricas**]{.hl-yellow} (por ejemplo, los d√≠as del mes). El comando `seq(inicio, fin)` nos permite crear una **secuencia** desde un elemento inicial hasta uno final, [**avanzando de uno en uno**]{.hl-purple}.

```{r}
seq(1, 31)
```

¬†

. . .

El comando `1:n` nos devuelve lo mismo que `seq(1, n)` (si el elemento inicial es mayor que el final, entender√° que la secuencia es **decreciente**)

```{r}
1:5
7:-3
```

---

## Secuencias num√©ricas

Tambi√©n podemos definir [**otro tipo de distancia**]{.hl-yellow} (paso) entre consecutivos

```{r}
seq(1, 7, by = 0.5) # secuencia desde 1 a 7 de 0.5 en 0.5
```

. . .

¬†

Otras veces nos interesar√° definir una [**secuencia con una longitud concreta**]{.hl-yellow}

```{r}
seq(1, 50, l = 7) # secuencia desde 1 a 50 de longitud 7
```

. . .

¬†

Incluso puede nos interese generar un vector de [**n elementos repetidos**]{.hl-yellow}

```{r}
rep(0, 7) # vector de 7 ceros
```

---

## Vectores de caracteres

Un vector es una **concatenaci√≥n** de elementos del [**mismo tipo**]{.hl-yellow}, pero no tienen porque ser necesariamente n√∫meros. Vamos a crear una frase de ejemplo.

```{r}
frase <- "Me llamo Javi"
frase
length(frase)
```

¬†

. . .

En el caso anterior no era un vector, era un solo elemento de texto. Para crear un vector debemos usar de nuevo `c()` y separar elementos entre comas

```{r}
vector <- c("Me", "llamo", "Javi")
vector
length(vector)
```

---

## Vectores de caracteres

¬øQu√© suceder√° si [**concatenamos elementos de diferente tipo**]{.hl-yellow}?

¬†

. . .

```{r}
c(1, 2, "javi", "3", TRUE)
```

F√≠jate que como todos tienen que ser del mismo tipo, lo que hace `R` es [**convertir**]{.hl-yellow} todo a texto, violando la [**integridad del dato**]{.hl-red}

¬†

. . .

```{r}
c(3, 4, TRUE, FALSE)
```

Es importante entender que los valores l√≥gicos en realidad est√°n [**almacenados internamente como 0/1**]{.hl-yellow}

---

## Operaciones con vectores

Con los vectores num√©ricos podemos hacer las mismas [**operaciones aritm√©ticas**]{.hl-yellow} que con los n√∫meros [‚Üí un [**n√∫mero es un vector**]{.hl-purple} (de longitud uno)]{.fragment .fade-in}


. . .

¬øQu√© suceder√° si [**sumamos o restamos un valor**]{.hl-yellow} a un vector?

. . .

```{r}
x <- c(1, 3, 5, 7)
x + 1
x * 2
```

::: callout-warning
## Cuidado

Salvo que indiquemos lo contrario, en `R` las operaciones con vectores son siempre [**elemento a elemento**]{.hl-orange}
:::

---

## Operaciones con vectores

Los vectores tambi√©n pueden interactuar entre ellos, as√≠ que podemos definir, por ejemplo, [**sumas de vectores**]{.hl-yellow} (elemento a elemento)

```{r}
x <- c(2, 4, 6)
y <- c(1, 3, 5)
x + y
```

¬†

. . .

Dado que la operaci√≥n (por ejemplo, una suma) se realiza elemento a elemento, ¬øqu√© suceder√° si [**sumamos dos vectores de distinta longitud**]{.hl-yellow}?

. . .

```{r}
z <- c(1, 3, 5, 7)
x + z
```

Lo que hace es [**reciclar elementos**]{.hl-yellow}: si tiene un vector de 4 elementos y sumamos otro de 3 elementos, lo que har√° ser√° reciclar del vector con menor longitud.

---

## Operaciones con vectores

Una operaci√≥n muy habitual es [**preguntar a los datos**]{.hl-yellow} mediante el uso de [**condiciones l√≥gicas**]{.hl-purple}. Por ejemplo, si definimos un vector de temperaturas...

[**¬øQu√© d√≠as hizo menos de 22 grados?**]{.hl-yellow}

```{r}
x <- c(15, 20, 31, 27, 15, 29)
```

. . .

```{r}
x < 22
```

Nos devolver√° un [**vector l√≥gico**]{.hl-yellow}, en funci√≥n de si **cada elemento** cumple o no la condici√≥n pedida.

. . .

Si tuvi√©ramos un [**dato ausente**]{.hl-yellow} (por error del aparato ese d√≠a), la condici√≥n evaluada tambi√©n ser√≠a `NA`

```{r}
y <- c(15, 20, NA, 31, 27, 7, 29, 10)
y < 22
```

---

## Operaciones con vectores

Las [**condiciones l√≥gicas pueden ser combinadas**]{.hl-yellow} de dos maneras:

-   [**Intersecci√≥n**]{.hl-yellow}: [**todas**]{.hl-purple} las condiciones concatenadas se deben cumplir ([**conjunci√≥n y**]{.hl-purple} con `&`) para devolver un `TRUE`

```{r}
x < 30 & x > 15
```

-   [**Uni√≥n**]{.hl-yellow}: basta con que [**al menos una**]{.hl-purple} se cumpla ([**conjunci√≥n o**]{.hl-purple} con `|`)

```{r}
x < 30 | x > 15
```

. . .

Con `any()` y `all()` podemos comprobar que [**todos los elementos**]{.hl-yellow} cumplen

```{r}
any(x < 30)
all(x < 30)
```

---

## Operaciones con vectores

Tambi√©n podemos hacer uso de [**operaciones estad√≠sticas**]{.hl-yellow} como por ejemplo `sum()` que, dado un vector, nos devuelve la suma de todos sus elementos.

```{r}
x <- c(1, -2, 3, -1)
sum(x)
```

¬†

[**¬øQu√© sucede cuando falta un dato (ausente)?**]{.hl-yellow}

. . .

```{r}
x <- c(1, -2, 3, NA, -1)
sum(x)
```

Por defecto, si tenemos un dato ausente, la [**operaci√≥n tambi√©n ser√° ausente**]{.hl-yellow}. Para poder [**obviar ese dato**]{.hl-purple}, usamos un argumento opcional `na.rm = TRUE`

```{r}
sum(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Como hemos comentado que los valores l√≥gicos son guardados internamente como 0 y 1, podremos usarlos en operaciones aritm√©ticas.

¬†

Por ejemplo, si queremos [**averiguar el n√∫mero de elementos que cumplen una condici√≥n**]{.hl-yellow} (por ejemplo, menores que 3), los que lo hagan tendr√°n asignado un 1 (`TRUE`) y los que no un 0 (`FALSE`) , por lo que basta con sumar dicho vector l√≥gico para obtener el n√∫mero de elementos que cumplen

```{r}
x <- c(2, 4, 6)
sum(x < 3)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

¬†

-   [**Media**]{.hl-yellow}: medida de centralidad que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. La m√°s conocida pero la [**menos robusta**]{.hl-red}: dado un conjunto, si se introducen valores at√≠picos o outliers (valores muy grandes o muy peque√±os), la media se perturba con mucha facilidad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, NA, 173, 177)
mean(x, na.rm = TRUE)
```

---

## Operaciones con vectores

Otras operaciones habituales son la [**media**]{.hl-yellow}, [**mediana**]{.hl-yellow}, [**percentiles**]{.hl-yellow}, etc.

¬†

-   [**Mediana**]{.hl-yellow}: medida de centralidad que consiste en ordenar los elementos y quedarse con el que ocupa la mitad.

```{r}
x <- c(165, 170, 181, 191, 150, 155, 167, 173, 177)
median(x)
```

. . .

-   [**Percentiles**]{.hl-yellow}: medidas de posici√≥n (nos dividen en partes iguales los datos).

```{r}
quantile(x) # por defecto percentiles 0-25-50-75-100
quantile(x, probs = c(0.1, 0.4, 0.9))
```

---

## Operaciones con vectores

Otra operaci√≥n muy habitual es la de [**acceder a elementos**]{.hl-yellow} del mismo. La forma m√°s sencilla es usar el operador `[i]` (acceder al elemento i-√©simo)

```{r}
edades <- c(20, 30, 33, NA, 61) 
edades[3] # accedemos a la edad de la tercera persona 
```

. . .

¬†

Dado que un n√∫mero no es m√°s que un vector de longitud uno, esta operaci√≥n tambi√©n la podemos aplicar usando un [**vector de √≠ndices a seleccionar**]{.hl-yellow}

```{r}
y <- c("hola", "qu√©", "tal", "est√°s", "?")
y[c(1:2, 4)] # primer, segundo y cuarto elemento
```

::: callout-tip
Para acceder al √∫ltimo, sin preocuparnos de cu√°l, podemos pasarle como √≠ndice la longitud `x[length(x)]`
:::

---

## Operaciones con vectores

Otras veces no querremos seleccionar sino [**eliminar algunos elementos**]{.hl-yellow}. Deberemos repetir la misma operaci√≥n pero con el signo - delante: el operador `[-i]` no selecciona el elemento i-√©simo del vector sino que lo ¬´des-selecciona¬ª

```{r}
y
y[-2]
```

¬†

. . .

En muchas ocasiones los queremos [**seleccionar o eliminar en base a condiciones l√≥gicas**]{.hl-yellow}, en funci√≥n de los valores, as√≠ que pasaremos como √≠ndice la propia condici√≥n (recuerda, `x < 2` nos devuelve un vector l√≥gico)

```{r}
edades <- c(15, 21, 30, 17, 45)
nombres <- c("javi", "mar√≠a", "laura", "carla", "luis")
nombres[edades < 18] # nombres de los menores de edad
```

---

## Operaciones con vectores

Por √∫ltimo, una acci√≥n habitual es saber [**ordenar valores**]{.hl-yellow}:

-   `sort()`: devuelve el [**vector ordenado**]{.hl-yellow}. Por defecto de menor a mayor pero con `decreasing = TRUE` podemos cambiarlo

```{r}
edades <- c(81, 7, 25, 41, 65, 20, 33, 23, 77)
sort(edades)
sort(edades, decreasing = TRUE)
```

. . .

-   `order()`: devuelve el [**vector de √≠ndices**]{.hl-yellow} que tendr√≠amos que usar para tener el vector ordenado

```{r}
order(x)
x[order(x)]
```

---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Define el vector `x` como la concatenaci√≥n de los 5 primeros n√∫meros impares, y calcula su suma.

```{r}
#| code-fold: true
#| eval: false
# Dos formas
x <- c(1, 3, 5, 7, 9)
x <- seq(1, 9, by = 2)

sum(x)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Obt√©n los elementos de `x` mayores que 4. Calcula el n√∫mero de elementos de `x` mayores que 4.

```{r}
#| code-fold: true
#| eval: false
x[x > 4]
sum(x > 4)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Calcula el vector `1/x` y obt√©n la versi√≥n ordenada (de menor a mayor).

```{r}
#| code-fold: true
#| eval: false
z <- 1/x
sort(z)
z[order(z)]
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Encuentra el m√°ximo y el m√≠nimo del vector `x`

```{r}
#| code-fold: true
#| eval: false
min(x)
max(x)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Encuentra del vector `x` los elementos mayores (estrictos) que 1 y menores (estrictos) que 7. Encuentra una forma de averiguar si todos los elementos son o no positivos.

```{r}
#| code-fold: true
#| eval: false
x[x > 1 & x < 7]
all(x > 0)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Dado el vector `x <- c(1, -5, 8, NA, 10, -3, 9)`, extrae los elementos que ocupan los lugares 1, 2, 5, 6. Elimina del vector el segundo elemento. Tras eliminarlo determina su suma y su media

```{r}
#| code-fold: true
#| eval: false
x <- c(1, -5, 8, NA, 10, -3, 9)
x[c(1, 2, 5, 6)]
y <- x[-2]
sum(y, na.rm = TRUE)
mean(y, na.rm = TRUE)
```
:::

# Primera base de datos

[**¬øC√≥mo construimos una tabla? Matrices, data.frame y tibble**]{style="color:#444442;"}

---

## Primer intento: matrices

Cuando analizamos datos solemos tener [**varias variables**]{.hl-yellow} de cada individuo: necesitamos una ¬´tabla¬ª que las recopile. La opci√≥n m√°s inmediata son las [**matrices**]{.hl-yellow}: concatenaci√≥n de variables del [**mismo tipo e igual longitud**]{.hl-purple}.

. . .

Imagina que tenemos estaturas y pesos de 4 personas. ¬øC√≥mo [**crear un dataset con las dos variables**]{.hl-yellow}? Con `cbind()` concatenamos en forma de columnas

```{r}
estaturas <- c(150, 160, 170, 180)
pesos <- c(60, 70, 80, 90)
cbind(estaturas, pesos)
```

. . .

¬†

[**No profundizaremos**]{.hl-red} m√°s ya que nuestro objetivo es tener variables de misma longitud pero [**tipos diferentes**]{.hl-yellow} (pero que sepas que existen).

---

## Segundo intento: data.frame

Las matrices tienen el mismo problema que los vectores: si juntamos datos de distinto tipo, se [**perturba la integridad del dato**]{.hl-red} ya que los convierte

```{r}
#| code-line-numbers: "4"
edades <- c(14, 24, NA)
soltero <- c(TRUE, NA, FALSE)
nombres <- c("javi", "laura", "luc√≠a")
cbind(edades, soltero, nombres)
```

¬†

. . .

Para poder trabajar con [**variables de distinto tipo**]{.hl-yellow} haremos uso de lo que se conoce como [**data.frame**]{.hl-yellow}: una variables de igual longitud pero [**tipo distinto**]{.hl-purple}.

```{r}
#| code-line-numbers: "1"
tabla <- data.frame(edades, soltero, nombres)
tabla
```

---

## Segundo intento: data.frame

```{r}
tabla
class(tabla)
```

¬†

. . .

Dado que un `data.frame` es ya una ¬´base de datos¬ª las variables no son meros vectores matem√°ticos: [**tienen un significado**]{.hl-yellow} y podemos (debemos) [**ponerles nombres**]{.hl-purple}

```{r}
library(lubridate)
tabla <- data.frame("edad" = edades, "estado" = soltero, "nombre" = nombres,
             "f_nacimiento" = as_date(c("1989-09-10", "1992-04-01", "1980-11-27")))
tabla
```

---

## Segundo intento: data.frame

[**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**]{.hl-yellow} Puedes visualizarlo escribiendo su nombre en consola o con `View(tabla)`

![](img/view_tabla.jpg)

---

## Segundo intento: data.frame

Si queremos acceder a sus elementos, el operador ser√° similar al de los vectores: ahora [**tenemos dos √≠ndices**]{.hl-yellow} (filas y columnas, dejando libre la que no usemos)

```{r}
tabla[2, ]  # segunda fila (todas sus variables)
tabla[, 3]  # tercera columna (de todos los individuos)
tabla[2, 1]  # primera caracter√≠stica de la segunda persona
```

. . .

::: columns
::: {.column width="35%"}
![](img/menu_data_frame.jpg)
:::

::: {.column width="65%"}
Tambi√©n tiene ventajas de una [**¬´base¬ª de datos**]{.hl-yellow} : podemos [**aceder a las variables por su nombre**]{.hl-purple} (recomendable ya que las variables pueden cambiar de posici√≥n), poniendo el nombre de la tabla seguido del s√≠mbolo `$` (con el **tabulador**, nos aparecer√° un men√∫ de columnas a elegir)
:::
:::

---

## Segundo intento: data.frame

-   `names()`: nos muestra los nombres de las variables

```{r}
names(tabla)
```

¬†

. . .

-   `dim()`: nos muestra las dimensiones (tambi√©n `nrow()` y `ncol()`)

```{r}
dim(tabla)
```

¬†

. . .

-   Podemos acceder a las variables por su nombre

```{r}
tabla[c(1, 3), "nombre"]
```

---

## Intento final: tibble

Las tablas en formato `data.frame` tienen algunas [**limitaciones**]{.hl-red}

La principal es que [**no permite la recursividad**]{.hl-red}: imagina que definimos una base de datos con estaturas y pesos, y queremos una tercera variable con el IMC

```{r}
#| error: true
data.frame("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
           "IMC" = peso / (estatura^2))
```

. . .

¬†

De ahora en adelante usaremos el formato `tibble` (un [**data.frame mejorado**]{.hl-yellow})

```{r}
library(tibble)
tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
       "IMC" = peso / (estatura^2))
```

---

## Intento final: tibble

```{r}
tabla <- tibble("estatura" = c(1.7, 1.8, 1.6), "peso" = c(80, 75, 70),
                "IMC" = peso / (estatura^2))
tabla
```

Las tablas en formato `tibble` nos permitir√° una [**gesti√≥n m√°s √°gil, eficiente y coherente**]{.hl-yellow} de los datos, con 4 ventajas principales:

. . .

-   [**Metainformaci√≥n**]{.hl-yellow}: si te fijas en la cabecera, nos dice ya autom√°ticamente el n√∫mero de filas y columnas, y el tipo de cada variable

. . .

-   [**Recursividad**]{.hl-yellow}: permite definir las variables secuencialmente (como hemos visto)

---

## Intento final: tibble

-   [**Consistencia**]{.hl-yellow}: si accedes a una columna que no existe avisa con un warning

```{r}
#| warning: true
tabla$invent
```

. . .

-   [**Por filas**]{.hl-yellow}: crear por filas (copiar y pegar de una tabla) con `tribble()`

```{r}
tribble(~colA, ~colB,
        "a",   1,
        "b",   2)
```

. . .

::: callout-tip
El paquete `{datapasta}` nos permite [**copiar y pegar**]{.hl-green} tablas de p√°ginas web y documentos sencillos
:::

---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Carga del paquete `{datasets}` el conjunto de datos `airquality` (contiene variables de la calidad del aire de la ciudad de Nueva York desde mayo hasta septiembre de 1973). ¬øEs el conjunto de datos airquality de tipo tibble? En caso negativo, convi√©rtelo a tibble (busca en la documentaci√≥n del paquete en <https://tibble.tidyverse.org/index.html>).

```{r}
#| code-fold: true
#| eval: false
library(tibble)
class(datasets::airquality)
airquality_tb <- as_tibble(datasets::airquality)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Una vez convertido a `tibble` obt√©n el nombre de las variables y las dimensiones del conjunto de datos. ¬øCu√°ntas variables hay? ¬øCu√°ntos d√≠as se han medido?

```{r}
#| code-fold: true
#| eval: false
names(airquality_tb)
ncol(airquality_tb)
nrow(airquality_tb)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Filtra solo los datos del mes de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, ]
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Selecciona aquellos datos que no sean ni de julio ni de agosto.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month %in% c(7, 8), ]
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Modifica el siguiente c√≥digo para quedarte solo con las variable de ozono y temperatura.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[, c("Ozone", "Temp")]
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Selecciona los datos de temperatura y viento de agosto. Traduce a castellano el nombre de las columnas del conjunto filtrado.

```{r}
#| code-fold: true
#| eval: false
airquality_tb[Month == 8, c("Temp", "Wind")]
names(airquality_tb) <- c("ozono", "rad_solar", "viento", "temp", "mes", "dia") 
```
:::

# R base vs Tidyverse

[**Spoiler: un multiverso de datos limpios**]{style="color:#444442;"}

---

## R base vs Tidyverse

Si conoces alg√∫n otro lenguaje de programaci√≥n (o tienes gente cercana que programa) te extra√±ar√° que a√∫n no hayamos hablado de conceptos habituales como

-   [**Bucles for**]{.hl-yellow}: repetir un c√≥digo un n√∫mero fijo de iteraciones.

-   [**Bucles while**]{.hl-yellow}: repetir un c√≥digo hasta que se cumpla una condici√≥n

-   [**Estructuras if-else**]{.hl-yellow}: estructuras de control para decidir por donde camina el c√≥digo en funci√≥n del valor de las variables.

¬†

. . .

Y aunque conocer dichas estructuras puede sernos en alg√∫n momento interesante, en la [**mayor√≠a de ocasiones vamos a poder evitarlas**]{.hl-red} (en especial los bucles) [‚Üí en lugar de trabajar con lo que se conoce como R Base vamos a vertebrar el curso en torno a [**Tidyverse**]{.hl-yellow}]{.fragment .fade-in}

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="50%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="50%"}
![](img/flow_tidyverse.jpg)
:::
:::

`{tidyverse}` es un [**¬´universo¬ª de paquetes**]{.hl-yellow} para garanatizar un flujo de trabajo (de inicio a fin) eficiente, coherente y lexicogr√°ficamente sencillo de entender, basado en la idea de que [**nuestros datos est√°n limpios y ordenados (tidy)**]{.hl-purple}

---

## ¬øQu√© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: optimizando data.frame
-   `{tidyr}`: limpieza de datos
-   `{readr}`: carga datos rectangulares (.csv)
-   `{dplyr}`: gram√°tica para depurar
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n
:::
:::

Tambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---


## ¬øQu√© es tidyverse?

::: columns
::: {.column width="45%"}
![](img/tidyverrse_universe.jpg)
:::

::: {.column width="55%"}
-   `{tibble}`: [**optimizando data.frame**]{.hl-yellow}
-   `{tidyr}`: [**limpieza de datos**]{.hl-yellow}
-   `{readr}`: [**carga datos**]{.hl-yellow} rectangulares (.csv)
-   `{dplyr}`: [**gram√°tica para depurar**]{.hl-yellow}
-   `{stringr}`: manejo de textos
-   `{ggplot2}`: visualizaci√≥n de datos
-   `{tidymodels}`: modelizaci√≥n/predicci√≥n
:::
:::

Tambi√©n tenemos los paquetes `{purrr}` para el manejo de listas, `{forcast}` para cualitativas, `{lubridate}` para fechas, `{readxl}` para importar archivos .xls y .xlsx, `{rvest}` para web scraping y `{rmarkdown}` para comunicar resultados.

---

## Filosof√≠a base: tidy data

> Tidy datasets are all alike, but every messy dataset is messy in its own way (Hadley Wickham, Chief Scientist en RStudio)

<div style="font-size:120px; text-align: center; color:#F8DF58;"><b>TIDY</b><span style="color:#CAB0EE;"><b>VERSE</b></span></div>

El [**universo**]{.hl-purple} de paquetes `{tidyverse}` se basa en la idea introducido por **Hadley Wickham** (el Dios al que rezo) de [**estandarizar**]{.hl-yellow} el formato los datos para

::: incremental

* [**sistematizar**]{.hl-green} la depuraci√≥n
* hacer m√°s [**sencillo**]{.hl-green} su manipulaci√≥n.
* c√≥digo [**legible**]{.hl-green}

:::
 
---

## Reglas del tidy data

Lo primero por tanto ser√° entender qu√© son los [**conjuntos tidydata**]{.hl-yellow} ya que todo `{tidyverse}` se basa en que los datos est√°n estandarizados.


:::: columns
::: {.column width="50%"}

::: {.fragment .fade-in}
1. Cada [**variable**]{.hl-yellow} en una [**√∫nica columna**]{.hl-purple}
:::

::: {.fragment .fade-in}
2. Cada [**individuo**]{.hl-yellow} en una [**fila diferente**]{.hl-purple}
:::

::: {.fragment .fade-in}
3. Cada [**celda**]{.hl-yellow} con un [**√∫nico valor**]{.hl-purple}
:::

::: {.fragment .fade-in}
4. Cada [**dataset**]{.hl-yellow} en un [**tibble**]{.hl-purple}
:::

::: {.fragment .fade-in}
5. Si queremos cruzar [**m√∫ltiples tablas**]{.hl-yellow} debemos tener una [**columna com√∫n**]{.hl-purple}
:::
:::
::: {.column width="50%"}
![](img/tidy_def.jpg){width="160%"}
:::
::::

---

## Tuber√≠a (pipe)

En `{tidyverse}` ser√° clave el [**operador pipe (tuber√≠a)**]{.hl-yellow} definido como `|>` ([**ctrl+shift+M**]{.hl-purple}): ser√° una [**tuber√≠a que recorre los datos**]{.hl-yellow} y los transforma.

. . .

:::: columns
::: {.column width="50%"}
En R base, si queremos aplicar tres funciones `first()`, `second()` y `third()` en orden, ser√≠a

```{r}
#| eval: false
third(second(first(datos)))
```
:::

::: {.column width="50%"}

En `{tidyverse}` podremos [**leer de izquierda a derecha**]{.hl-yellow} y separar los datos de las acciones

```{r}
#| eval: false
datos |> first() |> second() |> third()
```

:::
::::

&nbsp;

. . .

::: callout-caution
## Apunte importante

Desde la versi√≥n 4.1.0 de `R` disponemos de `|>`, un pipe **nativo**  disponible [**fuera de tidyverse**]{.hl-purple}, sustituyendo al [**antiguo pipe**]{.hl-red} `%>%` que depend√≠a del paquete `{magrittr}` (bastante problem√°tico).
:::

---

## Tuber√≠a (pipe)

La principal ventaja es que el [**c√≥digo sea muy legible (casi literal)**]{.hl-yellow} pudiendo hacer grandes operaciones con los datos con apenas c√≥digo.

&nbsp;

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::

::: {.column width="50%"}

<center><img src="img/logo_pipe.png" width="360px"/></center>
:::
::::
  

---

## Datos SUCIOS: messy data

¬øPero qu√© aspecto tienen los [**datos no tidy**]{.hl-yellow}? Vamos a cargar la tabla `table4a` del paquete `{tidyr}` (ya lo tenemos cargado del entorno tidyverse).

&nbsp;

```{r}
library(tidyr)
table4a
```


&nbsp;

[**¬øQu√© puede estar fallando?**]{.hl-red}

---

## Pivotar: pivot_longer()

:::: columns
::: {.column width="40%"}
```{r}
table4a
```
:::

::: {.column width="60%"}

‚ùé  Cada [**fila representa dos observaciones**]{.hl-red} (1999 y 2000) ‚Üí las columnas `1999` y `2000` en realidad deber√≠an ser en s√≠ [**valores de una variable**]{.hl-yellow} y no nombres de columnas.
:::
::::

. . .

Incluiremos una [**nueva columna**]{.hl-yellow} que nos guarde el a√±o y otra que guarde el valor de la variable de inter√©s en cada uno de esos a√±os. Y lo haremos con la funci√≥n `pivot_longer()`: [**pivotaremos la tabla**]{.hl-yellow} a formato long:

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "cases")
```


---

## Pivotar: pivot_longer()

:::: columns

::: {.column width="50%"}

```{r}
table4a |> 
  pivot_longer(cols = c("1999", "2000"),
               names_to = "year",
               values_to = "cases")
```

:::

::: {.column width="50%"}

![](img/table4a.jpg)

:::
::::

&nbsp;

* `cols`: [**nombre de las variables a pivotar**]{.hl-yellow}
* `names_to`: nombre de la nueva variable a la quemandamos la [**cabecera**]{.hl-yellow} de la tabla (los nombres).
* `values_to`: nombre de la nueva variable a la que vamos a mandar los [**datos**]{.hl-yellow}.

---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table2`

&nbsp;

```{r}
table2
```


&nbsp;

[**¬øQu√© puede estar fallando?**]{.hl-red}

---


## Pivotar: pivot_wider()

:::: columns
::: {.column width="60%"}
```{r}
#| echo: false
table2
```
:::

::: {.column width="40%"}

‚ùé Cada [**observaci√≥n est√° dividido en dos filas**]{.hl-red} ‚Üí los [**registros con el mismo a√±o deber√≠an ser el mismo**]{.hl-yellow}

:::
::::

. . .

Lo que haremos ser√° lo opuesto: con `pivot_wider()` [**ensancharemos la tabla**]{.hl-yellow}

```{r}
table2 |>  pivot_wider(names_from = type, values_from = count)
```


---

## Datos SUCIOS: messy data

Veamos otro ejemplo con la tabla `table3`

&nbsp;

```{r}
table3
```


&nbsp;

[**¬øQu√© puede estar fallando?**]{.hl-red}

---


## Separar: separate()

:::: columns
::: {.column width="60%"}
```{r}
table3
```
:::

::: {.column width="40%"}

‚ùé Cada [**celda contiene varios valores**]{.hl-red} 

:::
::::

. . .

Lo que haremos ser√° hacer uso de la funci√≥n `separate()` para mandar [**separar cada valor**]{.hl-yellow} a una columna diferente.

```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

---

## Separar: separate()


```{r}
table3 |> separate(rate, into = c("cases", "pop"))
```

F√≠jate que los datos, aunque los ha separado, [**los ha mantenido como texto**]{.hl-red} cuando en realidad deber√≠an ser variables num√©ricas. Para ello podemos a√±adir el argumento opcional `convert = TRUE`

. . .

```{r}
table3 |> separate(rate, into = c("cases", "pop"), convert = TRUE)
```

---

## Datos SUCIOS: messy data

Veamos el √∫ltimo ejemplo con la tabla `table5`

&nbsp;

```{r}
table5
```


&nbsp;

[**¬øQu√© puede estar fallando?**]{.hl-red}

---


## Unir unite()

:::: columns
::: {.column width="50%"}
```{r}
table5
```
:::

::: {.column width="50%"}

‚ùé Tenemos [**mismos valores divididos en dos columnas**]{.hl-red} 

:::
::::

. . .

Usaremos `unite()` para [**unir los valores**]{.hl-yellow} de siglo y a√±o en una misma columna

```{r}
table5 |> unite(col = year_completo, century, year, sep = "")
```

---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset
### [**Ejercicio 1**]{.hl-yellow}

üìù Echa un vistazo a la tabla `table4b` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
table4b |>
  pivot_longer(cols = "1999":"2000", names_to = "year",
               values_to = "cases")
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Echa un vistazo a la tabla `relig_income` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
relig_income |>
  pivot_longer(cols = "<$10k":"Don't know/refused",
               names_to = "income",
               values_to = "people")
```


### [**Ejercicio 3**]{.hl-yellow}

üìù Echa un vistazo a la tabla `billboard` del paquete `{tidyr}`. ¬øEs tidydata? En caso negativo, ¬øqu√© falla? ¬øC√≥mo convertirla a tidy data en caso de que no lo sea ya?

```{r}
#| code-fold: true
#| eval: false
billboard |>
  pivot_longer(cols = "wk1":"wk76",
               names_to = "week",
               names_prefix = "wk",
               values_to = "position",
               values_drop_na = TRUE)
```

:::

# Introducci√≥n a Tidyverse

[**Con los datos limpicos, vamos a trabajarlos**]{style="color:#444442;"}

---

## Preprocesamiento: dplyr

Dentro de `{tidyverse}` usaremos el paquete `{dplyr}` para el [**preprocesamiento y depuraci√≥n**]{.hl-yellow} de datos de datos.

:::: columns
::: {.column width="65%"}
![](img/dplyr.png)
:::

::: {.column width="35%"}
```{r}
#| eval: false
datos |>
  limpio(...) |>
  filtro(...) |>
  selecciono(...) |>
  ordeno(...) |>
  modifico(...) |>
  renombro(...) |>
  agrupo(...) |>
  cuento(...) |>
  resumo(...) |>
  pinto(...)
```
:::
::::

---

## Filtrar filas: filter()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
::::

Una de las operaciones m√°s comunes es [**filtrar registros**]{.hl-yellow} en base a alguna condici√≥n l√≥gica: con `filter()` se seleccionar√°n solo individuos que cumplan ciertas condiciones.

::: incremental

* `==`, `!=`: [**igual**]{.hl-purple} o [**distinto**]{.hl-purple} que
* `>`, `<`: [**mayor**]{.hl-purple} o [**menor**]{.hl-purple} que
* `>=`, `<=`: [**mayor o igual**]{.hl-purple} o [**menor o igual**]{.hl-purple} que
* `%in%`: valores [**pertenencen**]{.hl-purple} a un listado de opciones
* `between(variable, val1, val2)`: si los valores (normalmente continuos) [**caen dentro de un rango**]{.hl-purple} de valores

:::

---

## Filtrar filas: filter()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
::::

¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes de [**ojos marrones**]{.hl-purple}?

. . .

```{r}
#| echo: false
#| include: false
library(tidyverse)
```

# ```{r}
# starwars |> filter(eye_color == "brown")
# ```

---

## Filtrar filas: filter()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
::::

¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**no tienen ojos marrones**]{.hl-purple}?

. . .

# ```{r}
# starwars |> filter(eye_color != "brown")
# ```

---

## Filtrar filas: filter()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
::::

¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan los ojos marrones o azules**]{.hl-purple}?

. . .

# ```{r}
# starwars |> filter(eye_color %in% c("blue", "brown"))
# ```

---

## Filtrar filas: filter()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
::::

¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**midan entre 120 y 160 cm**]{.hl-purple}?

. . .

# ```{r}
# starwars |> filter(between(height, 120, 160))
# ```

::: callout-tip

## Importante
Recuerda que dentro de `filter()` debe ir siempre algo que devuelva un [**vector de valores l√≥gicos**]{.hl-green}.

:::

---


## Filtrar filas: filter()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
::::

¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos**]{.hl-purple}?

. . .

# ```{r}
# starwars |>
#   filter(eye_color == "brown" & species != "Human")
# ```

---

## Filtrar filas: filter()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  filtro(condicion)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  filter(condicion)
```
:::
::::

¬øC√≥mo har√≠as... [**filtrar**]{.hl-yellow} los personajes que [**tengan ojos y no sean humanos, o que tengan m√°s de 60 a√±os**]{.hl-purple}?

. . .

# ```{r}
# starwars |>
#   filter((eye_color == "brown" & species != "Human") | birth_year > 60)
# ```

  
---

## Eliminar ausentes: drop_na()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  retirar_ausentes(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  drop_na(var1, var2, ...)
```
:::
::::

Hay un filtro especial que es el de [**retirar los ausentes**]{.hl-yellow}, para lo cual podemos usar `filter(is.na(variable))` o directamente `drop_na()`: si no indicamos variable, elimina registros con ausente en cualquiera de las variables.

. . .

&nbsp;

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> drop_na(mass, height)
```

```{r}
#| echo: false
starwars |>
  drop_na(mass, height, sex) |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> drop_na()
```

```{r}
#| echo: false
starwars |>
  drop_na() |> 
  select(name, mass, height, hair_color) |> 
  slice(1:7)
```

:::
::::


---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Selecciona del conjunto de starwars solo los personajes que sean androides o cuyo valor en `species` sea desconocido
 
```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Droid" | is.na(species))
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Selecciona del conjunto de starwars solo los personajes cuyo peso est√© entre 65 y 90 kg.

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(between(mass, 65, 90))
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Tras limpiar de ausentes en todas las variables, selecciona del conjunto de starwars solo los personajes que sean humanos y que vengan de Tatooine

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na() |> 
  filter(species == "Human" & homeworld == "Tatooine")
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Selecciona del conjunto original de starwars los personajes no humanos, `male` en el sexo y que midan entre 120 y 170 cm, o los personajes con ojos marrones o rojos.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter((species != "Human" & sex == "male" &
            between(height, 120, 170)) |
           eye_color %in% c("brown", "red"))
```

### [**Ejercicio 5**]{.hl-yellow}

üìù  Busca informaci√≥n en la ayuda de la funci√≥n `str_detect()` del paquete `{stringr}` (cargado en `{tidyverse}`). Consejo: prueba antes las funciones que vayas a usar con alg√∫n vector de prueba para poder comprobar su funcionamiento. Tras saber lo que hace, filtra solo aquellos personajes con apellido `Skywalker`

```{r}
#| code-fold: true
#| eval: false
starwars |> filter(str_detect(name, "Skywalker"))
```

:::

---

## Rebanadas de datos: slice()


:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
::::

Normalmente filtraremos condici√≥n pero a veces nos puede interesar [**filtrar por posici√≥n**]{.hl-yellow}: con `slice(posiciones)` podremos seleccionar filas concreetas pasando como argumento un [**vector de √≠ndices**]{.hl-yellow}

. . .

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(1)
```

```{r}
#| echo: false
starwars |> slice(1) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(7:9)
```

```{r}
#| echo: false
starwars |> slice(7:9) |> select(name:hair_color)
```
:::
::::

. . .

```{r}
#| eval: false
starwars |> slice(c(2, 7, 10, 31))
```


```{r}
#| echo: false
starwars |> slice(c(2, 7, 10, 31)) |> select(name:sex)
```

---

## Rebanadas de datos: slice()


:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> rebanadas(posiciones)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice(posiciones)
```
:::
::::

Disponemos de opciones por defecto: con `slice_head(n = ...)` y `slice_tail(n = ...)` podemos obtener la [**cabecera y cola**]{.hl-yellow} de la tabla

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_head(n = 2)
```
```{r}
#| echo: false
starwars |> slice_head(n = 2) |> select(name:hair_color)
```
:::

::: {.column width="50%}
```{r}
#| eval: false
starwars |> slice_tail(n = 2)
```
```{r}
#| echo: false
starwars |> slice_tail(n = 2) |> select(name:hair_color)
```
:::
::::

. . .

Con `slice_max()` y `slice_min()` obtenemos la [**filas con menor/mayor valor de una variable**]{.hl-yellow} (si empate, todas salvo que `with_ties = FALSE`).

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_min(mass, n = 2)
```
```{r}
#| echo: false
starwars |> slice_min(n = 2, order_by = mass) |> select(name:hair_color)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> slice_max(height, n = 2)
```
```{r}
#| echo: false
starwars |> slice_max(n = 2, order_by = height) |> select(name:hair_color)
```
:::
::::


---


## Reordenar filas: arrange()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> ordenar(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(var1, var2, ...)
```
:::
::::

Tambi√©n podemos [**ordenar filas**]{.hl-yellow} en funci√≥n de alguna variable con `arrange()`

```{r}
#| eval: false
starwars |> arrange(mass)
```

```{r}
#| echo: false
starwars |> arrange(mass) |> select(name:eye_color) |> slice(1:5) 
```

. . .

Por [**defecto de menor a mayor**]{.hl-yellow} pero podemos [**invertir el orden**]{.hl-purple} con `desc()`

:::: columns
::: {.column width="50%"}

```{r}
#| eval: false
starwars |> arrange(desc(height))
```

```{r}
#| echo: false
starwars |> arrange(desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
::: {.column width="50%"}
```{r}
#| eval: false
starwars |> arrange(mass, desc(height))
```

```{r}
#| echo: false
starwars |> arrange(mass, desc(height)) |> select(name:mass) |> slice(1:5) 
```
:::
::::

---

## Eliminar duplicados: distinct()

Muchas veces necesitaremos asegurarnos que no hay duplicados en alguna variable (DNI) y podemos [**eliminar filas duplicadas**]{.hl-yellow} con `distinct()`. 

```{r}
starwars |> distinct(sex)
```

. . .

Para mantener todas las columnas de la tabla usaremos `.keep_all = TRUE`.

```{r}
#| eval: false
starwars |> distinct(sex, .keep_all = TRUE)
```

```{r}
#| echo: false
starwars |> distinct(sex, .keep_all = TRUE) |> slice(1:3)
```


---

## A√±adir filas: bind_rows()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> encuadernar_filas(tibble2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
tibble1 |> bind_rows(tibble2)
```
:::
::::

Por √∫ltimo, podemos [**concatenar nuevas filas**]{.hl-yellow} con `bind_rows()` con [**las nuevas observaciones en tabla**]{.hl-red} (si no cuadran columnas rellena con ausentes)


```{r}
datos <-
  tibble("nombre" = c("javi", "laura"), "edad" = c(33, 50))
datos
```


. . .

```{r}
datos |> bind_rows(tibble("nombre" = c("carlos", NA), "cp" = c(28045, 28019)))
```


---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Selecciona solo los personajes que sean humanos y de ojos marrones, para despu√©s ordernarlos en altura descendente y peso ascendente.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(eye_color == "brown" & species == "Human") |> 
  arrange(height, desc(mass))
```

### [**Ejercicio 2**]{.hl-yellow}


üìù Extrae 3 registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(n = 3)
```

### [**Ejercicio 3**]{.hl-yellow}


üìù Extrae el 10% de los registros aleatoriamente.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_sample(prop = 0.1)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Extrae aleatoriamente 10 personajes pero de forma que la probabilidad de que salga cada uno sea proporcional a su peso (m√°s pesados, m√°s probable)

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass) |> 
  slice_sample(n = 10, weight_by = mass)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Selecciona los 3 personajes m√°s mayores.

```{r}
#| code-fold: true
#| eval: false
starwars |> slice_max(birth_year, n = 3)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Para saber que valores √∫nicos hay en el color de pelo, elimina duplicados de la variable `hair_color`, eliminando antes los ausentes de dicha variable.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(hair_color) |> 
  distinct(hair_color)
```

### [**Ejercicio 7**]{.hl-yellow}

üìù De los personajes que son humanos y miden m√°s de 160 cm, elimina duplicados en color de ojos, elimina ausentes en peso, selecciona los 3 m√°s altos, y orden de mayor a menor peso. Devuelve la tabla.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  filter(species == "Human" & height > 160) |> 
  distinct(eye_color, .keep_all = TRUE) |> 
  drop_na(mass) |> 
  slice_max(height, n = 3) |> 
  arrange(desc(mass))
```


:::

---


## Selecci√≥n columnas: select()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
::::

La opci√≥n m√°s sencilla para [**seleccionar variables por nombre**]{.hl-yellow} es  `select()`, dando como argumentos los nombres de columnas sin comillas.

```{r}
starwars %>% select(name, hair_color)
```

---

## Selecci√≥n columnas: select()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
::::


La funci√≥n `select()` nos permite seleccionar varias variables a la vez [**concatenando sus nombres como si fuesen √≠ndices**]{.hl-yellow}

```{r}
#| eval: false
starwars |> select(name:eye_color) 
```

```{r}
#| echo: false
starwars |> select(name:eye_color) |> slice(1:4)
```

. . .

Y podemos [**deseleccionar columnas**]{.hl-yellow} con `-`

```{r}
#| eval: false
starwars |>  select(-mass, -(eye_color:starships))
```

```{r}
#| echo: false
starwars |> select(-mass, -(eye_color:starships)) |> slice(1:4)
```


---

## Selecci√≥n columnas: select()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
::::

Tenemos adem√°s [**palabras reservadas**]{.hl-yellow}: `everything()` [**todas las variables**]{.hl-purple}...

```{r}
#| eval: false
starwars |> select(mass, homeworld, everything())
```

```{r}
#| echo: false
starwars |> select(mass, homeworld, everything()) |> slice(1:4)
```

. . .

...y `last_col()` para referirnos a [**la √∫ltima columna**]{.hl-purple}.

```{r}
#| eval: false
starwars |> select(name:mass, homeworld, last_col())
```

```{r}
#| echo: false
starwars |> select(name:mass, homeworld, last_col()) |> slice(1:4)
```

---

## Selecci√≥n columnas: select()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
::::


Podemos jugar con [**patrones**]{.hl-yellow} en el nombre, aquellas que [**comiencen por un prefijo**]{.hl-purple} (`starts_with()`), [**terminen con un sufijo**]{.hl-purple} (`ends_with()`), [**contengan un texto**]{.hl-purple} (`contains()`) o cumplan una [**expresi√≥n regular**]{.hl-purple} (`matches()`).


```{r}
# variables cuyo nombre acaba en "color" y contengan sexo o g√©nero
starwars |> select(ends_with("color"), matches("sex|gender"))
```


---


## Selecci√≥n columnas: select()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
::::


Incluso podemos [**seleccionar por rango num√©rico**]{.hl-yellow} si tenemos variables con un prefijo y n√∫meros.

```{r}
datos <-
  tibble("semana1" = c(115, 141, 232), "semana2" = c(7, NA, 17),
         "semana3" = c(95, 162, NA), "semana4" = c(11, 19, 15),
         "semana5" = c(NA, 262, 190), "semana6" = c(21, 15, 23))
```


. . .

Con `num_range()` podemos seleccionar con un prefijo y una secuencia num√©rica.

```{r}
datos |> select(num_range("semana", 1:4))
```

---


## Selecci√≥n columnas: select()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> selecciono(var1, var2, ...)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> select(var1, var2, ...)
```
:::
::::


Por √∫ltimo, podemos seleccionar columnas por [**tipo de dato**]{.hl-yellow} haciendo uso de `where()` y dentro una funci√≥n que devuelva un valor l√≥gico de tipo de dato.

```{r}
# Solo columnas num√©ricas o de texto
starwars |> select(where(is.numeric) | where(is.character))
```

---


## Mover columnas: relocate()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  recolocar(var1, despues_de = var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  relocate(var1, .after = var2)
```
:::
::::

Para facilitar la [**recolocaci√≥n de variables**]{.hl-yellow} tenemos una funci√≥n para ello, `relocate()`, indic√°ndole en `.after` o `.before` [**detr√°s**]{.hl-purple} o [**delante**]{.hl-purple} de qu√© columnas queremos moverlas.

```{r}
starwars |> relocate(species, .before = name)
```



---

## Renombrar: rename()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> renombrar(nuevo = antiguo)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> rename(nuevo = antiguo)
```
:::
::::

A veces tambi√©n podemos querer [**modificar la ¬´metainformaci√≥n¬ª**]{.hl-yellow} de los datos, [**renombrando columnas**]{.hl-yellow}. Para ello usaremos de `rename()` poniendo [**primero el nombre nuevo**]{.hl-purple} y luego el [**antiguo**]{.hl-purple}.

```{r}
starwars |> rename(nombre = name, altura = height, peso = mass)
```

---

## Modificar columnas: mutate()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
::::

En muchas ocasiones querremos [**modificar o crear variables**]{.hl-yellow} con `mutate()`. Vamos a crear por ejemplo una nueva variable `height_m` con la altura en metros.

```{r}
starwars |> mutate(height_m = height / 100)
```

---

## Modificar columnas: mutate()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
::::

Adem√°s con los argumentos opcionales podemos [**recolocar la columna modificada**]{.hl-yellow}

```{r}
starwars |> 
  mutate(height_m = height / 100,
         IMC = mass / (height_m^2), .before = name)
```

---


## Modificar columnas: mutate()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> modificar(nueva = funcion())
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> mutate(nueva = funcion())
```
:::
::::

::: callout-important
## Importante...

Cuando aplicamos `mutate()`, debemos de acordarnos que las [**operaciones se realizan de manera vectorial**]{.hl-yellow}, elemento a elemento, por lo que la funci√≥n que usemos dentro debe devolver un vector de igual longitud. En caso contrario, [**devolver√° una constante**]{.hl-red}
:::

. . .

```{r}
starwars |> 
  mutate(constante = mean(mass, na.rm = TRUE), .before = name)
```


---

## Recategorizar: if_else()

Tambi√©n podemos combinar `mutate()` con la expresi√≥n de control `if_else()` para [**recategorizar la variable**]{.hl-yellow}: si [**se cumple una condici√≥n**]{.hl-purple}, hace una cosa, en caso contrario otra.

```{r}
starwars |> 
  mutate(human = if_else(species == "Human", "Human", "Not Human"),
         .after = name) |> 
  select(name:mass)
```


---

## Recategorizar: case_when()

Para [**recategorizaciones m√°s complejas**]{.hl-yellow} tenemos  `case_when()`, por ejemplo, para crear una categor√≠a de los personajes en funci√≥n de su altura.
 
```{r}
starwars |> 
  drop_na(height) |> 
  mutate(altura = case_when(height < 120 ~ "enanos",
                            height < 160 ~ "bajito",
                            height < 180 ~ "normal",
                            height < 200 ~ "alto",
                            TRUE ~ "gigante"), .before = name)
```

---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Selecciona solo las variables nombre, altura y as√≠ como todas aquellas variables relacionadas con el color, a la vez que te quedas solo con aquellos que no tengan ausente en la altura.
 
```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Con los datos obtenidos del ejercicio anterior, traduce el nombre de las columnas a castellano.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Con los datos obtenidos del ejercicio anterior, coloca la variable de color de pelo justo detr√°s de la variable de nombres.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  select(name, height, contains("color")) |> 
  drop_na(height) |> 
  rename(nombre = name, altura = height,
         color_pelo = eye_color, color_piel = skin_color,
         color_pelo = hair_color) |> 
  relocate(color_pelo, .after = nombre)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Con los datos originales, comprueba cu√°ntas modalidades √∫nicas hay en la variable de color de pelo.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  distinct(hair_color) |> 
  nrow()
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Del dataset original, selecciona solo las variables num√©ricas y de tipo texto. Tras ello define una nueva variable llamada `under_18` que nos recategorice la variable de edad: `TRUE` si es menor de edad y `FALSE` en caso contrario

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  select(where(is.numeric) | where(is.character)) |> 
  mutate(under_18 = birth_year < 18)
```

### [**Ejercicio 6**]{.hl-yellow}

üìù Del dataset original, crea una nueva columna llamada `auburn` (cobrizo/caoba) que nos diga TRUE si el color de pelo contiene dicha palabra y FALSE en caso contrario (reminder `str_detect()`).

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(auburn = str_detect(hair_color, "auburn"))
```

### [**Ejercicio 7**]{.hl-yellow}

üìù Del dataset original, incluye una columna que calcule el IMC. Tras ello, crea una nueva variable que valga `NA` si no es humano, `delgadez` por debajo de 18, `normal` entre 18 y 30, `sobrepeso` por encima de 30.

```{r}
#| code-fold: true
#| eval: false
starwars |> 
  mutate(IMC = mass / ((height/100)^2),
         IMC_recat = case_when(species != "Human" ~ NA,
                               IMC < 18 ~ "delgadez",
                               IMC < 30 ~ "normal",
                               TRUE ~ "sobrepeso"),
         .after = name)
```

:::

---

## Contar: count()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
::::

Hasta ahora solo hemos transformado o consultado los datos pero no hemos generado estad√≠sticas. Empecemos por lo sencillo: [**¬øc√≥mo contar (frecuencias)?**]{.hl-yellow}

. . .

Cuando lo usamos en solitario `count()` nos devolver√° simplemente el n√∫mero de registros , pero cuando lo usamos con variables `count()` calcula lo que se conoce como [**frecuencias**]{.hl-yellow}: [**n√∫mero de elementos de cada modalidad**]{.hl-purple}. 

```{r}
starwars |> count(sex)
```

---

## Contar: count()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> contar(var1, var2)
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> count(var1, var2)
```
:::
::::

Adem√°s si pasamos varias variables nos calcula lo que se conoce como una [**tabla de contigencia**]{.hl-yellow}. Con `sort = TRUE` nos devolver√° el [**conteo ordenado**]{.hl-purple} (m√°s frecuentes primero).

```{r}
starwars |> count(sex, gender, sort = TRUE)
```

---

## Agrupar: group_by()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
::::

Una de las [**funciones m√°s potentes**]{.hl-yellow} a combinar con las acciones vistas es `group_by()`, que nos permitir√° [**agrupar nuestros registros**]{.hl-yellow} previamente

```{r}
starwars |> 
  group_by(sex) |>
  count() |>
  ungroup()
```

---

## Agrupar: group_by()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
::::

Cuando apliquemos `group_by()` es importante entender que [**NO MODIFICA los datos**]{.hl-yellow}, sino que nos crea una [**variable de grupo**]{.hl-yellow} (subtablas por cada grupo) que modificar√° las acciones futuras: las [**operaciones se aplicar√°n a cada subtabla por separado**]{.hl-purple}

. . .

Por ejemplo, imaginemos que queremos extraer el personaje m√°s alto con `slice_max()`.

```{r}
starwars |> slice_max(height)
```

---

## Agrupar: group_by()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
::::

¬øY si queremos [**extraer el personaje m√°s alto pero...de cada uno de los sexos**]{.hl-yellow}?

. . .

```{r}
starwars |>
  group_by(sex) |> 
  slice_max(height) |> 
  ungroup()
```

---

## Agrupar: group_by()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |> 
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |> 
  ungroup()
```
:::
::::

:::: columns
::: {.column width="50%"}
![](img/tidydatatutor_1.jpg)
:::

::: {.column width="50%"}
![](img/tidydatatutor_2.jpg)
:::
::::

La web <https://tidydatatutor.com/> permite visualizar las operaciones de `{tidyverse}` (con el pipe antiguo)

---


## Agrupar: group_by()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |>
  agrupar(var1, var2) |> 
  accion() |>
  desagrupar()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |>
  group_by(var1, var2) |> 
  accion() |>
  ungroup()
```
:::
::::

::: callout-important
## Importante
Recuerda siempre [**hacer ungroup**]{.hl-red} para eliminar la variable de grupo creada
:::

. . .

En la nueva versi√≥n de `{dplyr}` ahora se [**permite incluir la variable de grupo**]{.hl-yellow} en la llamada a muchas funciones con el argumento `by = ...` o `.by = ...`

# ```{r}
# #| eval: false
# starwars |> slice_max(height, by = sex)
# ```
# 
# ```{r}
# #| echo: false
# starwars |> slice_max(height, by = sex) |> select(name:eye_color)
# ```

---

## Fila-a-fila: rowwise()

Una opci√≥n muy √∫til usada antes de una operaci√≥n tambi√©n es `rowwise()`: toda [**operaci√≥n que venga despu√©s se aplicar√° en cada fila por separado**]{.hl-yellow}. Por ejemplo, vamos a definir un conjunto dummy de notas.

```{r}
notas <- tibble("mates" = c(7.5, 8, 9.1, 3),
                "lengua" = c(8, 6, 6.5, 9.2))
```

. . .

Si aplicamos la media directamente el valor ser√° id√©ntico ya que nos ha hecho la media global, pero nos gustar√≠a sacar una [**media por registro**]{.hl-yellow}. Para eso usaremos `rowwise()`

```{r}
notas |> 
  rowwise() |> 
  mutate(media_curso = mean(c(mates, lengua)))
```


---

## Resumir: summarise()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
::::

Por √∫ltimo tenemos `summarise()`, que nos permitir√° sacar res√∫menes estad√≠sticos. Por ejemplo, vamos a [**calcular la media de las alturas**]{.hl-yellow}.

```{r}
starwars |> 
  drop_na(height) |> 
  summarise(media_altura = mean(height))
```

. . .

::: callout-warning
## Cuidado
F√≠jate que `mutate()` devuelve [**tantas filas como registros originales**]{.hl-yellow}, mientras que con `summarise()` calcula un [**nuevo dataset de resumen**]{.hl-purple}, solo incluyendo aquello que est√© indicado.
:::

---

## Resumir: summarise()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> summarise()
```
:::
::::

Si adem√°s esto lo [**combinamos con la agrupaci√≥n**]{.hl-yellow} de `group_by()` o `.by = ...`, en pocas l√≠neas de c√≥digo puedes obtener [**estad√≠sticas desagreagadas**]{.hl-purple}

```{r}
starwars |> 
  drop_na(sex, height, mass) |> 
  summarise(media_altura = mean(height),
            media_peso = mean(mass),
            .by = sex)
```

---

## Resumir: reframe()

:::: columns
::: {.column width="50%"}
```{r}
#| eval: false
datos |> resumir()
```
:::

::: {.column width="50%"}
```{r}
#| eval: false
starwars |> reframe()
```
:::
::::

En el nuevo `{dplyr}` han incluido `reframe()` para evitar problemas de `summarise()` cuando [**devolvemos m√°s de un valor por variable**]{.hl-yellow}.

:::: columns
::: {.column width="50%"}
```{r}
#| warning: true
starwars |>
  drop_na(mass) |>
  summarise(quantile(mass))
```
:::
::: {.column width="50%"}
# ```{r}
# starwars |>
#   drop_na(mass) |>
#   reframe(quantile(mass))
# ```
:::
::::

---

## Selectores: across()

Un truco es [**hacer uso de selectores**]{.hl-yellow} `across()` y `where()`. El primero nos permite [**actuar sobre varias columnas por  nombre**]{.hl-purple} (con `mutate()` o `summarise()`)

```{r}
starwars |> summarise(medias = across(height:mass, mean, na.rm = TRUE), .by = sex)
```

. . .

El segundo, `where()`, nos permite hacer lo mismo pero [**seleccionando por tipo**]{.hl-yellow}.

```{r}
starwars |> 
  summarise(across(where(is.numeric), mean, na.rm = TRUE), .by = c(sex, gender))
```

---

## üíª Tu turno

[**Intenta realizar los siguientes ejercicios sin mirar las soluciones**]{style="color:#444442;"}

::: panel-tabset

### [**Ejercicio 1**]{.hl-yellow}

üìù Calcula cu√°ntos personajes hay de cada especie, ordenados de m√°s a menor frecuencia.


```{r}
#| code-fold: true
#| eval: false
starwars |> count(species, sort = TRUE)
```

### [**Ejercicio 2**]{.hl-yellow}

üìù Tras eliminar ausentes en las variables de peso y estatura, a√±ade una nueva variable que nos calcule el IMC de cada personaje, y determina el IMC medio de nuestros personajes desagregada por sexo


```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(mass, height) |> 
  mutate(IMC = mass / ((height/100)^2)) |> 
  summarise(IMC_medio = mean(IMC), .by = sex)
```

### [**Ejercicio 3**]{.hl-yellow}

üìù Obt√©n el personaje m√°s joven por cada sexo.


```{r}
#| code-fold: true
#| eval: false
starwars |>
  slice_min(birth_year, by = sex)
```

### [**Ejercicio 4**]{.hl-yellow}

üìù Obt√©n la edad del personaje m√°s joven y m√°s viejo de cada sexo.

```{r}
#| code-fold: true
#| eval: false
starwars |>
  drop_na(birth_year) |>
  summarise(min(birth_year), max(birth_year), .by = sex)
```

### [**Ejercicio 5**]{.hl-yellow}

üìù Determina la cantidad de personajes en cada d√©cada (echa un vistazo a `round()`, primero sin desagregar y luego desagregado por sexo.


```{r}
#| code-fold: true
#| eval: false
starwars |>
  count(birth_decade = round(birth_year, -1))
```

:::


# Caso real: datos de encuestas

[**Pongamos en pr√°ctica lo aprendido...**]{style="color:#444442;"}

---

## Caso real: datos de encuestas

El paquete `{readr}` (ya en `{tidyverse}`) nos permite realizar una carga m√°s √°gil y m√°s inteligente que el `read.csv()` de base (lo importa a un `tibble` e interpreta bien el tipo de cada variable, incluso fechas)

```{r}
#| echo: false
#| eval: false
encuestas <- read_csv(file = "./datos/historical_surveys.csv")
encuestas <-
  encuestas |>
  mutate(cod_elec = "02") |> 
  select(type_survey, date_elec, id_pollster, pollster,
         media, field_date_from, field_date_to, exit_poll,
         size, turnout, abbrev_candidacies, est_vote) |> 
  pivot_wider(names_from = "abbrev_candidacies",
              values_from = "est_vote")
write_csv(encuestas, file = "./datos/historical_surveys.csv")
```

```{r}
encuestas <- read_csv(file = "./datos/historical_surveys.csv")
encuestas
```

---

## Caso real: datos de encuestas

Lo [**primero que debes hacer**]{.hl-yellow} es visualizar con `View()` la tabla para entenderla

. . .

* [**Primera tarea**]{.hl-purple}: crea una variable llamada `id_survey` que nos permita identificar a cada encuesta. ¬øQu√© podr√≠amos concatenar?

```{r}
#| code-fold: true
encuestas <-
  encuestas |> 
  # Creamos un id con type_survey-date_elec-id_pollster
  # con .before la ponemos delante de everything(), de todo (1¬™ col)
  mutate(id_survey = glue("{type_survey}-{date_elec}-{id_pollster}"),
         .before = everything())
```

---

## Caso real: datos de encuestas

* [**Segunda tarea**]{.hl-purple}: usando la variable `id_survey` creada elimina duplicados.


```{r}
#| code-fold: true
encuestas <-
  encuestas |>
  # Eliminamos duplicados por id_survey, pero mantenemos todas las
  # columnas con .keep_all = TRUE
  distinct(id_survey, .keep_all = TRUE)
```

---

## Caso real: datos de encuestas

* [**Tercera tarea**]{.hl-purple}: tenemos una variable `media` que representa el medio en el que se public√≥ o encargo la encuesta. Elimina dicha variable, as√≠ como el tipo de encuesta y el id de la encuestadora


```{r}
#| code-fold: true
encuestas <-
  encuestas |> 
  # Eliminamos las columnas pedidas con un -
  # las concateno para usar solo un - para todas
  select(-c(type_survey, id_pollster, media))
```

---

## Caso real: datos de encuestas


* [**Cuarta tarea**]{.hl-purple}: qu√©date solo con las encuestas cuyo tama√±o muestral conozcamos y que no sean encuestas a pie de urna. Elimina esta √∫ltima variable.

# ```{r}
# #| code-fold: true
# encuestas <-
#   encuestas |> 
#   # eliminar ausentes
#   drop_na(size) |> 
#   # Filtramos encuestas (registros) a pie de urna (aquellas que exit_poll == FALSE)
#   filter(!exit_poll) |> 
#   # Quitamos la variable pie de urna
#   select(-exit_poll)
# ```


---

## Caso real: datos de encuestas


* [**Quinta tarea**]{.hl-purple}: convierte el dataset en tidydata. ¬øQu√© falla? ¬øC√≥mo arreglarlo? Reminder: no quremos ausentes.

```{r}
#| code-fold: true
encuestas <-
  encuestas |> 
  # Convertimos a tidydata
  pivot_longer(cols = -(id_survey:turnout),
               names_to = "partido",
               values_to = "est_voto",
               values_drop_na = TRUE)
```

---

## Caso real: datos de encuestas


* [**Sexta tarea**]{.hl-purple}: calcula el n√∫mero de d√≠as que la encuesta ha hecho trabajo de campo, y coloca dicha columna tras el nombre de la encuestadora. Tras ello elimina aquellas encuestas que tengan 0 d√≠as de trabajo de campo.

# ```{r}
# #| code-fold: true
# encuestas <-
#   encuestas |> 
#   # Calculamos los d√≠as de campo como la diferencia de fechas 
#   # con as.numeric() convertimos la dif. de fechas a un n√∫mero
#   mutate(n_dias_campo = as.numeric(field_date_to - field_date_from),
#          .after = pollster) |> 
#   # Solo aquellas cuyo trabajo de campo haya durado 1 d√≠a o m√°s
#   filter(n_dias_campo > 0)
# ```

---

## Caso real: datos de encuestas


* [**S√©ptima tarea**]{.hl-purple}: calcula el n√∫mero de d√≠as que faltan hasta las elecciones desde que la encuesta cerro el trabajo de campo y coloca dicha variable tras `n_dias_campo`. Tras ello elimina las fechas de inicio y fin de trabajo de campo de la manera m√°s eficiente posible

# ```{r}
# #| code-fold: true
# encuestas <-
#   encuestas |> 
#   # Calculamos los d√≠as que faltan a las elecciones
#   # con as.numeric() convertimos la dif. de fechas a un n√∫mero
#   mutate(n_dias_elec = as.numeric(date_elec - field_date_to),
#          .after = n_dias_campo) |> 
#   # Eliminamos ya las fechas de campo que no necesitamos
#   select(-contains("field"))
# ```

---

## Caso real: datos de encuestas


* [**Octava tarea**]{.hl-purple}: elimina encuestas que se hayan cerrado dentro de la ventana temporal en la que est√° prohibido la publicaci√≥n de encuestas (no se deber√≠an usar para predecir ya que ¬´no se conocen¬ª)

# ```{r}
# #| code-fold: true
# encuestas <-
#   encuestas |>
#   # Solo con encuestas antes del baneo electoral
#   filter(n_dias_elec > 15)
# ```

---

## Caso real: datos de encuestas


* [**Novena tarea**]{.hl-purple}: obt√©n, por cada elecci√≥n, la media de las encuestas de cada partido

# ```{r}
# #| code-fold: true
# encuestas |>
#   # Resumen: media de voto por fecha y partido
#   summarise(media_voto = mean(est_voto),
#             .by = c("date_elec", "partido"))
# ```

---

## Caso real: datos de encuestas


* [**D√©cima tarea**]{.hl-purple}: realiza lo mismo que la tarea anterior pero solo para las encuestas de los 60 d√≠as previos a las elecciones. Ordena la salida de reciente a antiguo

# ```{r}
# #| code-fold: true
# encuestas |>
#   # Filtramos ventana de 60 d√≠as
#   filter(n_dias_elec <= 60) |>
#   # Media de est_voto por fecha y partido
#   summarise(media_voto = mean(est_voto),
#             .by = c("date_elec", "partido")) |>
#   # Ordenar de mayor a menor
#   arrange(desc(date_elec))
# ```

---

## Caso real: datos de encuestas


* [**Und√©cima tarea**]{.hl-purple}: del dataset generado en el anterior ejercicio, obt√©n el primer y el segundo con mayor estimaci√≥n de voto (en promedio)

# ```{r}
# #| code-fold: true
# encuestas |> 
#   # Filtramos ventana de 60 d√≠as
#   filter(n_dias_elec <= 60) |> 
#   # Media de est_voto por fecha y partido
#   summarise(media_voto = mean(est_voto),
#             .by = c("date_elec", "partido")) |>
#   # Ordenar de mayor a menor por fecha
#   arrange(desc(date_elec)) |>
#   # extraemos los dos con m√°s est de voto (por cada fecha)
#   slice_max(media_voto, n = 2, by = date_elec)
# ```

# El mundo Github

[**Trabajar ordenados, publicar resultados, replicabilidad de lo realizado**]{style="color:#444442;"}

---

## ¬øQu√© es Github?

[**GitHub**]{.hl-yellow} es la plataforma colaborativa m√°s conocida basada en el [**sistema de control de versiones Git**]{.hl-yellow}

. . .

* [**¬øQu√© es Git?**]{.hl-purple} Git es un sistema de [**control de versiones**]{.hl-yellow}: una especie de [**Dropbox**]{.hl-yellow} para facilitar la [**programaci√≥n colaborativa**]{.hl-yellow} entre un grupo de personas, permitiendo llevar la [**trazabilidad de los cambios**]{.hl-yellow} realizados.

. . .

* [**¬øQu√© es Github?**]{.hl-purple} Nuestra [**plataforma/interfaz**]{.hl-yellow} para ejecutar el control de versiones: nos servir√° no solo para trabajar colaborativamente sino para [**hacer transparente**]{.hl-yellow} el proceso de construcci√≥n de nuestros proyectos de c√≥digo.

. . .

::: callout-important
## Importante

Desde el 4 de junio de 2018 Github es de Microsoft (ergo el c√≥digo que subas tambi√©n)

:::

---

## Visi√≥n general

Tras hacernos una cuenta en Github, [**arriba a la derecha**]{.hl-purple} tendremos un c√≠rculo, y haciendo click en [**Your Profile**]{.hl-purple}, veremos algo similar a esto

:::: columns
::: {.column width="55%"}

![](img/github_1.png)

:::

::: {.column width="45%"}
* [**Edit profile**]{.hl-purple}: nos permite a√±adir una [**descripci√≥n y foto de perfil**]{.hl-yellow}.

* [**Overview**]{.hl-purple}: en ese panel de cuadrados se [**visualizar√° nuestra actividad**]{.hl-yellow} a lo largo del tiempo.


* [**Repositories**]{.hl-purple}: el c√≥dugo ser√° subido a [**repositorios**]{.hl-yellow}, el equivalente a nuestras carpetas compartidas en Dropbox.

:::
::::

---

## Primer uso: consumidor

Antes de aprender como crear repositorios, Github tambi√©n nos servir√° para

* [**Acceder a c√≥digo**]{.hl-purple} ajeno
* [**Proponer mejoras**]{.hl-purple} a otros usuarios, e incluso proponer [**correcciones de error que detectemos**]{.hl-yellow} de software que usemos

. . .

* [**Instalar paquetes de R**]{.hl-purple}. En muchas ocasiones los desarrolladores de paquetes suben las actualizaciones a CRAN cada cierto tiempo, y en otras el software no es suficientemente ¬´amplio¬ª para poder ser subido como paquete.

El c√≥digo de paquetes que no tengamos subido en CRAN podremos [**instalarlo como c√≥digo desde Github**]{.hl-yellow}

---

## Instalar desde Github


Por ejemplo, vamos a instalar un paquete llamado [`{peRReo}`](https://github.com/jbgb13/peRReo), cuya √∫nica funci√≥n es darnos [**paletas de colores**]{.hl-yellow} basadas en portadas de [**√°lbumes de m√∫sica urbana**]{.hl-yellow}

:::: columns
::: {.column width="50%"}

![](img/perrreo.png)

:::

::: {.column width="50%"}

![](img/rosalia.png){width="360"}
:::
::::

. . .

Para ello antes tendremos que instalar un [**conjunto de paquetes para desarrolladores**]{.hl-yellow} llamado `{devtools}`, que nos permitir√° la instalaci√≥n desde Github

```{r}
#| eval: false
install.packages("devtools")
```

---

## Instalar desde Github

Las [**instrucciones de instalaci√≥n**]{.hl-yellow} suelen venir detalladas en la portada del repositorio

:::: columns
::: {.column width="50%"}

![](img/install_perreo.png)

:::

::: {.column width="50%"}

![](img/rosalia.png){width="310"}
:::
::::

. . .

En la mayor√≠a de casos bastar√° con la funci√≥n `install_github()` (del paquete que acabamos de instalar), pas√°ndole como argumento la [**ruta del repositorio**]{.hl-yellow} (sin "github.com/"). 

```{r}
#| eval: false
devtools::install_github("jbgb13/peRReo")
```


Ya puedes perrear con ggplot ;)


---

## Descargar desde Github

La mayor√≠a de veces lo que subamos no ser√° un paquete de R como tal sino que [**subiremos un c√≥digo m√°s o menos organizado**]{.hl-yellow} y comentado. En ese caso podremos [**descargar el repo entero**]{.hl-yellow} haciendo click [**Code**]{.hl-green} y luego Download ZIP.

Por ejemplo, vamos a descargarnos los scripts de dataviz que han subido desde el [Centre d'Estudis d'Opini√≥](https://github.com/ceopinio/bop-grafics)

![](img/ceo_github.png)

---


## Ideal

![](img/abogados_simpson.jpeg){width="600"}

[**¬øLo ideal en caso de RTVE?**]{.hl-purple} Tener dos tipos de repositorios

* Una [**colecci√≥n de repositorios p√∫blicos (producci√≥n)**]{.hl-yellow} donde hacer transparente el c√≥digo y los datos ([**ya validados**]{.hl-purple}), coordinado por un n¬∫ reducido de personas.

* Una [**colecci√≥n de repositorios privados (desarrollo)**]{.hl-yellow} donde est√© todo el equipo colaborando y donde se haga el [**trabajo del d√≠a**]{.hl-purple}, con trazabilidad interna.


---

## Nuestro primer repositorio

Vamos a [**crear nuestro primero repositorio**]{.hl-yellow} que servir√° adem√°s como [**carta de presentaci√≥n**]{.hl-yellow} de nuestro perfil en Github.

1. [**Repositories**]{.hl-purple}: hacemos click en las pesta√±a de Repositories.

2. [**New**]{.hl-purple}: hacemos click en el [**bot√≥n verde New**]{.hl-green} para crear un nuevo repositorio


![](img/new_repo.png)


---

## Nuestro primer repositorio

* [**Repository name**]{.hl-purple}: el [**nombre del repositorio**]{.hl-yellow}. En este caso vamos a crear un repositorio muy concreto: el nombre debe [**coincidir exactamente con tu nombre de usuario**]{.hl-yellow}

* [**Description**]{.hl-purple}: descripci√≥n de tu repositorio. En este caso ser√° un repo de presentaci√≥n.

![](img/repo_init_1.png)

---


## Nuestro primer repositorio

* [**Public vs private**]{.hl-purple}: con cada repositorio tendremos la opci√≥n de hacer el repositorio


  - [**p√∫blico**]{.hl-purple}: todos los usuarios podr√°n ver el c√≥digo as√≠ c√≥mo la trazabilidad de su desarrollo (qu√© se a√±ade y cu√°ndo). Es para m√≠ la opci√≥n m√°s recomendable cuando quieres darle [**visibilidad y transparencia**]{.hl-yellow} a tu trabajo
  - [**privado**]{.hl-purple}: solo tendr√°n acceso al repositorio aquellos usuarios a los que se lo permitas. No se podr√° visualizar ni instalar nada de √©l fuera de Github.

![](img/repo_init_2.png)


En este caso concreto, dado que ser√° un repositorio de presentaci√≥n, lo [**haremos p√∫blico**]{.hl-yellow}.

---

## Nuestro primer repositorio

* [**Add a README file**]{.hl-purple}: un README file ser√° el archivo donde incluiremos las [**instrucciones y detalles de uso**]{.hl-yellow} a los dem√°s (en el caso de `{peRReo}` era el archivo que conten√≠a los detalles de instalaci√≥n)

![](img/repo_init_3.png)

De momento [**ignoraremos los dem√°s campos**]{.hl-red} para este primer repositorio.

---

## Nuestro primer repositorio

![](img/repo_init_1.png)

Por defecto Github asume que este repositorio, con el [**mismo nombre que nuestro usuario**]{.hl-yellow} ser√° el repositorio que querremos que se presente de inicio cuando alguien entra en nuestro perfil, y ser√° el repositorio donde [**incluir en el README.md**] una presentaci√≥n de nosotros y un √≠ndice de tu trabajo (si quieres).

---

## Nuestro primer repositorio

![](img/profile_github_md.png)

F√≠jate que ahora en nuestra [**portada tenemos dicho README.md**]{.hl-yellow} que podemos personalizar a nuestro gusto haciendo uso de [**html y markdown**]{.hl-yellow}.

Aqu√≠ puedes ver [**algunos ejemplos de README.MD**](https://github.com/matiassingers/awesome-readme)

---

## Repo de c√≥digo

Una vez que tenemos nuestro README de presentaci√≥n (recuerda que puedes [**personalizar a tu gusto con html y markdown**]{.hl-yellow}) vamos a crear un [**repositorio de c√≥digo**]{.hl-yellow}.

. . .

Si ya era importante [**trabajar con proyectos**]{.hl-yellow} en `RStudio`, cuando lo combinamos con Github es a√∫n m√°s crucial que creemos un proyecto antes de subir el c√≥digo, as√≠ que vamos a crear uno de prueba que se llame `repo-github-1`.

. . .

En dicho proyecto vamos a [**crear un script**]{.hl-yellow} (en mi caso llamado **codigo.R**) en el que deber√°s hacer los siguientes pasos:

---

## Repo de c√≥digo

1. [**Carga**]{.hl-yellow} directamente desde la p√°gina del [ISCIII](https://cnecovid.isciii.es/covid19/resources) el archivo llamado `casos_hosp_uci_def_sexo_edad_provres.csv`

```{r}
#| eval: false
#| code-fold: true
# Carga de datos desde ISCIII
datos_covid <- read_csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
```

. . .


2. [**Filtra**]{.hl-yellow} datos de Madrid (`"M"`), de 2020 y con sexo conocido (hombre/mujer). Tras ello qu√©date con las columnas `fecha`, `sexo`, `grupo_edad`, `num_casos` (ese orden). Por √∫ltimo obt√©n la suma de casos diarios por fecha y sexo. 

```{r}
#| eval: false
#| code-fold: true
# Depuraci√≥n
datos_madrid <-
  datos_covid |>
  # Filtrado por Madrid y fecha
  filter(provincia_iso == "M" & fecha <= "2020-12-31" & sexo != "NC") |> 
  # Selecci√≥n de columnas
  select(provincia_iso:fecha, num_casos) |> 
  # Resumen de casos diarios por fecha y sexo
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
  
```

---

## Repo de c√≥digo


3. [**Exporta el dataset a un csv**]{.hl-yellow} en una carpeta que se llame `exportado`

```{r}
#| eval: false
#| code-fold: true
# Exportamos datos
write_csv(datos_madrid, file = "./exportado/datos_madrid.csv")
```

. . .

:::: columns
::: {.column width="40%"}

4. Crea una [**gr√°fica de l√≠neas**]{.hl-yellow} que tenga en el eje x fecha, en el eje y casos, con una curva por sexo (gr√°ficas separadas). 

```{r}
#| eval: false
#| code-fold: true
# Gr√°fica
ggplot(datos_madrid) +
  geom_line(aes(x = fecha, y = num_casos, color = sexo),
            alpha = 0.6, linewidth = 0.7) +
  scale_color_manual(values = c("#85519D", "#278862")) +
  facet_wrap(~sexo) +
  theme_minimal() +
  theme(legend.position = "bottom")
```
:::

::: {.column width="60%"}
![](./img/ggplot.png){width=380}
:::
::::

. . .

5. Tras ello [**exportamos la gr√°fica**]{.hl-yellow}

```{r}
#| eval: false
ggsave(filename = "./exportado/ggplot.png", plot = last_plot(),
       bg = "white", width = 12, height = 8)
```

---

## Repo de c√≥digo

¬øC√≥mo [**subimos el proyecto**]{.hl-yellow}? Vamos de nuevo a [**crear un proyecto de cero**]{.hl-yellow}. Antes no hemos hablado de dos campos importantes:


:::: columns
::: {.column width="50%"}

![](./img/repo-1.png){width=460}
:::

::: {.column width="50%"}

* `Add .gitignore` nos permitir√° [**seleccionar el lenguaje**]{.hl-yellow} en el que estar√° nuestro proyecto para que Github lo entienda al sincronizar (y no actualice cosas que no deba).

* `Choose a license` nos permitir√° [**seleccionar la licencia**]{.hl-yellow} que determinar√° las condiciones en las que otros podr√°n reusar tu c√≥digo.

:::
::::

---

## Repo de c√≥digo


:::: columns
::: {.column width="50%"}

![](./img/repo-1-1.png)
:::

::: {.column width="50%"}

Si te fijas traer crearlo tenemos solo 3 archivos: el de licencia, el .gitignore y el readme.md (donde deber√≠amos escribir una gu√≠a de uso de lo que hayamos subido)
:::
::::

Para subir los archivos vamos a clickar en [**Add file < Upload File**]{.hl-purple} y [**arrastraremos TODOS los archivos**]{.hl-yellow} de la carpeta de nuestro proyecto.

---

## Repo de c√≥digo

Tras la subida de archivos tendremos un cuadro llamado [**Commit changes**]{.hl-purple}


![](./img/commit-1.png)


Un [**commit**]{.hl-purple} es una [**modificaci√≥n del repositorio**]{.hl-yellow} con algo que se a√±ade/elimine/modifique, y dicho cuadro es recomendable usarlo para [**resumir en qu√© consiste la modificaci√≥n**]{.hl-yellow}, de manera que quede trazado el cambio.

---


## Repo de c√≥digo

Haciendo click en el reloj donde indica el [**n√∫mero de commits**]{.hl-yellow} accedemos al [**hist√≥rico de commits (cambios)**]{.hl-yellow} con hora, d√≠a, autor, comentarios, etc.

![](./img/commit-reloj.png)

---

## Repo de c√≥digo

Vamos a realizar un [**cambio en nuestro c√≥digo**]{.hl-yellow}: en tu c√≥digo local (local --> tu ordenador), en lugar de filtrar por Madrid haz el [**filtro por Barcelona**]{.hl-yellow}, guarda el c√≥digo y sube en el repositorio el nuevo archivo (con el mismo nombre, Github har√° la sobrescritura)

```{r}
#| eval: false
#| code-line-numbers: "3"
datos_bcn <-
  datos_covid |>
  filter(provincia_iso == "B" & fecha <= "2020-12-31" & sexo != "NC") |> 
  select(fecha, sexo, grupo_edad, num_casos) |> 
  summarise(num_casos = sum(num_casos), .by = c(fecha, sexo))
```

---

## Consulta de commits

![](./img/barcelona_covid.png){width=550}

:::: columns
::: {.column width="40%"}
Si ahora [**consultamos el commit**]{.hl-yellow}, al lado hay un n√∫mero que lo identifica, y clickando en √©l nos resume los cambios: no solo [**almacena todas las versiones pasadas**]{.hl-yellow} sino que adem√°s nos [**muestra las diferencias entre los archivos cambiados**]{.hl-yellow}
:::

::: {.column width="60%"}
![](./img/commit_cambio.png)
:::
::::

---

## Trazabilidad de cambios


::: columns
::: {.column width="72%"}
![](./img/commit_split.png)
![](./img/commit_unified.png)
:::

::: {.column width="28%"}
Tenemos [**dos modos de visualizaci√≥n**]{.hl-yellow} de los cambios: el modo split nos muestra el antiguo y el nuevo, con las inclusiones en verde y lo que ya no est√° en rojo; y el modo unified nos muestra todo en un mismo documento.
:::
::::

---

## Recuperaci√≥n de commits

![](./img/browse-repo.png)

Github nos permite incluso [**recuperar una versi√≥n del pasado**]{.hl-yellow} de nuestro repositorio, haciendo click en el tercer icono del commit.

---

## Recuperaci√≥n de commits

![](./img/branch-commit.png)

Si te fijas ahora al lado de `1 branch` tenemos un [**men√∫ desplegable**]{.hl-yellow} en el que antes pon√≠a `main` y ahora un n√∫mero identificador del commit. Ya hablaremos de la idea de [**rama (branch)**]{.hl-yellow}

---

## Repo con rmd/qmd


:::: columns
::: {.column width="60%"}

Vamos a poner en pr√°ctica lo aprendido:

1. Crea un nuevo repositorio en Github (llamado `repo-github-2`) donde habr√° alojado con proyecto de R.

2. Crea un proyecto en `RStudio` que se llame (por ejemplo) `proyecto-qmd`

3. Una vez dentro del proyecto en `RStudio` haz click en `File < New File < Quarto Document`

:::
::: {.column width="40%"}
![](./img/primer-qmd.png)
:::
::::

Deber√°s tener un documento similar a este: un [**quarto markdown (.qmd)**]{.hl-yellow}, un documento que nos permitir√° incluir [**markdown + c√≥digo**]{.hl-yellow} (puede ser `R` o puede ser `Observable`, `D3`, etc).

---

## Repo con rmd/qmd

Este formato es ideal para:

* [**Trabajar en equipo**]{.hl-yellow} construyendo el borrador de una pieza.
* Tomar [**apuntes o informes**]{.hl-yellow} para uno mismo.
* [**Presentar**]{.hl-yellow} tu trabajo a tus compa√±eros.

:::: columns
::: {.column width="50%"}
![](./img/prueba-qmd-html.png)

:::
::: {.column width="50%"}
Si te fijas ahora nuestro repositorio tiene un archivo con formato `.html`...es decir...

[**¬°Es una web!**]{.hl-yellow}
:::
::::

---

## Github pages

¬øC√≥mo [**convertir nuestro repositorio en una web**]{.hl-yellow}?

![](./img/github-pages.png)

1. Haz click en `Settings`
2. Ve al apartado `Pages`
3. En el subapartado `branch` selecciona la √∫nica rama que tenemos ahora (`main`)
4. Selecciona la carpeta donde tengas el `.html` (en web complejas estar√° como en cualquier web en `docs`, en algo simple estar√° en la ruta raiz del repositorio)
5. Haz click en `Save`

---

## Github pages

Si te fijas en la [**parte superior del repositorio**]{.hl-yellow} ahora tenemos un icono naranja, que nos indica que la [**web est√° en proceso de ser desplegada (deploy)**]{.hl-orange}

![](./img/github-naranja.png)

---

## Github pages

Pasados unos segundos (dependiendo del tama√±o de la web y tu conexi√≥n a internet) ese [**icono pasar√° a ser un check verde**]{.hl-green}: habemus web

![](./img/github-verde.png)


El [**link de la web por defecto**]{.hl-yellow} ser√° `{nombre_usuario}.github.io/{nombre_repo}`

---

## Github pages


![](./img/github-pages-deploy.png)

¬°Un momento! Ahora mismo nuestra web [**no nos est√° mostrando nuestro .qmd**]{.hl-red}, sino por defecto el [**README.md**]{.hl-yellow}.

. . .

Para que Github entienda que queremos visualizar ese `.html` que hemos generado a partir del `.qmd` vamos en nuestro proyecto local a [**borrar**]{.hl-yellow} todo lo que no sea nuestro archivo `.Rproj` y nuestro archivo `.qmd`, y vamos a [**cambiar el nombre**]{.hl-yellow} a este √∫ltimo llam√°ndolo `index.qmd`, y volvemos a compilarlo para [**generar un index.html**]{.hl-yellow}

---

## Github pages

Vamos a [**subir a Github ese nuevo proyecto**]{.hl-yellow} con el cambio de nombre (llamado `repo-github-3`) para ver luego las diferencias entre uno y otro


![](./img/repo-index-html.png)

---

## Github pages

Si [**repetimos el proceso para hacer una Page**]{.hl-yellow} y esperamos al tick verde...

:::: columns
::: {.column width="50%"}
![](./img/index-html-qmd.png)
:::
::: {.column width="50%"}

Si a tu `.qmd` ya le llamas de inicio `index.qmd`, autom√°ticamente, al detectar Github un `index.html`, interpreta que ese [**archivo index.html**]{.hl-yellow} es el que define la web (y puedes personalizar a√±adiendo un archivo `css` de estilos)

[**Habemus web**]{.hl-green} simplemente clickando en Pages :)

:::
::::


---

## Repo con diapositivas

Vamos a crear el √∫ltimo repositorio que se llamar√° `repo-diapos`, y crear un proyecto en `RStudio` del mismo nombre (por ejemplo). Una vez creado le daremos a `File < New File < Quarto Presentation`.


:::: columns
::: {.column width="45%"}
![](img/quarto-slides.png)
:::
::: {.column width="55%"}
La forma de escribir ser√° igual que un `.qmd` normal solo que ahora [**cada diapositiva la separaremos**]{.hl-yellow} con un `---` (usando archivos de estilos podemos personalizar lo que queramos)

Llama al archivo directamente `index.qmd`, s√∫belo a Github y con un click en Pages tienes una [**web con tus diapositivas**]{.hl-yellow}
:::
::::



---

## Uso de Gitkraken

La forma m√°s [**sencilla para trabajar de manera colaborativa**]{.hl-yellow} en Github, y tenerlo sincronizado con nuestro local, es hacer uso de [Gitkraken](https://www.gitkraken.com/download)


:::: columns
::: {.column width="50%"}
![](img/gitkraken-repo.png)
:::

::: {.column width="50%"}

Una vez dentro clickamos en el icono de la carpeta (`Repo Management`) y si ya tenemos el repositorio en Github seleccionamos `Clone`, indicando donde queremos clonar (en nuestro local) y que [**repositorio de Github queremos clonar**]{.hl-yellow}.

:::
::::

---

## Uso de Gitkraken


:::: columns
::: {.column width="50%"}
![](img/view-change.png)
:::


::: {.column width="50%"}
Una vez clonado, la idea es que cada [**cambio que hagamos en local nos aparecer√° en Gitkraken**]{.hl-yellow} como `View changes`.

:::
::::

---

## Uso de Gitkraken

Cuando tengas suficientes cambios como para [**actualizar el repositorio**]{.hl-yellow} (tampoco tiene sentido actualizar con cada edici√≥n), ver√°s algo similar a esto con todos los [**commits realizados**]{.hl-yellow}



:::: columns
::: {.column width="50%"}
![](img/stage-all-changes.png)
:::


::: {.column width="50%"}
Podr√°s decidir cu√°les de los [**commits locales quieres incluir en remoto**]{.hl-yellow}, bien uno a uno o en `Stage all changes` (para todos)

:::
::::


---

## Uso de Gitkraken


Tras incluir los commits deber√°s incluir un [**t√≠tulo y descripci√≥n del commit**]{.hl-yellow}

![](img/titulo-commit.png)

---

## Uso de Gitkraken


Tras hacerlo ver√°s que ahora tenemos [**dos iconos separados en una especie de √°rbol**]{.hl-yellow} (¬øte acuerdas de la `branch` o rama?):

* [**Ordenador**]{.hl-purple}: la versi√≥n del repositorio que tienes en tu [**ordenador**]{.hl-yellow}.

* [**Logo**]{.hl-purple}: la versi√≥n del repositorio que tienes [**subida en remoto**]{.hl-yellow} 

![](img/split-gitkraken.png)

---

## Uso de Gitkraken

Mientras eso suceda solo tendr√°s sincronizado tu ordenador con Gitkraken, pero no con Github. Para ello haremos [**click en Push**]{.hl-yellow} (con `Pull` podr√°s forzar a tener en local lo mismo que en remoto).

![](img/push-gitkraken.png)

---

## Branchs

Como hemos mencionado ya en varias ocasiones, hay un elefante en la habitaci√≥n que a√∫n no hemos mentado: las [**ramas o branchs**]{.hl-yellow} de un repositorio.

. . .

Imagina que est√°is trabajando varios en un proyecto y tene√≠s una versi√≥n que funciona pero que quer√©is [**modificar en paralelo a partir del estado actual**]{.hl-yellow} del repositorio.

. . .

Las [**ramas**]{.hl-yellow} nos permiten partir de una versi√≥n com√∫n del repositorio y hacer cambios que [**no afecten a los dem√°s**]{.hl-yellow}

---

## Branchs

Para [**crear una rama**]{.hl-yellow} a partir del estado actual de repositorio haremos click en `Branch` y le pondremos un nombre


![](img/branch-button.png)

Una vez creada ver√°s [**dos iconos**]{.hl-yellow} y un [**men√∫ desplegable**]{.hl-yellow} con las distintas ramas en las que quieres hacer el commit. Imagina que realizas un cambio pero [**no quieres a√±adirlo a la rama principal**]{.hl-yellow}: puedes hacer el [**commit en tu rama propia en LOCAL**]{.hl-yellow} (lo har√°s en la rama activa de tu men√∫ de branchs).




---

## Branchs

La primera vez te pedir√° que escribas la [**rama en REMOTO**]{.hl-yellow} con la quieres sincronizar tu rama en local. [**Consejo**]{.hl-green}: ponle el mismo nombre en remoto que en local.

![](img/name-branch.png)

---

## Branchs

F√≠jate que ahora tenemos el ordenador y el logo en el mismo sitio. Esto no significa que tengas ambas ramas en tu local, solo que [**Gitkraken tiene ambas sincronizadas**]{.hl-yellow}: clickando en cualquiera de ellas, tus archivos en tu ordenador cambiar√°n.

![](img/both-branchs.png)

---

## Pull request

Lo m√°s recomendable es que [**solo se incorpore de una rama secundaria**]{.hl-yellow} a la rama principal aquello que est√° [**validado por un/a coordinador/a**]{.hl-yellow} del repositorio, asegur√°ndose que todo funciona correctamente. 

Cuando queramos incluirlo haremos [**click con bot√≥n derecho**]{.hl-yellow} en el icono de la rama secundaria y seleccionamos `Start a pull request to origin from...`

![](img/pull-request-menu.png)


. . .

Una [**pull request**]{.hl-yellow} ser√° una [**petici√≥n al responsable de la rama principal**]{.hl-yellow} para incluir los cambios

---

## Pull request

:::: columns
::: {.column width="60%"}
![](img/create-pull-request.png)
:::

::: {.column width="40%"}
En el cuadro que no se abre deberemos escribir:

* La [**rama**]{.hl-yellow} a la que hacer el `merge` (normalmente la `main`)
* T√≠tulo y resumen de los cambios
* Puedes incluso asignar un [**revisor**]{.hl-yellow} entre los colaboradores del repo.
* Puedes asignar [**etiquetas**]{.hl-yellow}
:::
::::

---

## Pull request

Mientras no se acepte aparecer√° un [**icono de rama**]{.hl-yellow} y un +1 en Pull Requests

![](img/pending-branch.png){width=500}

. . .

Si somos al mantenedor del repositorio, haciendo click en el men√∫ nos saldr√°n las ramas que nos quieren hacer hacer `merge`

![](img/menu-pr.png){width=500}

---

## Pull request

Al hacer click se abrir√° un [**cuadro de Pull Request**]{.hl-yellow} para decidir si

* [**Revisar**]{.hl-yellow} los cambios
* [**Aprobar**]{.hl-yellow} el `merge`
* [**A√±adir comentarios**]{.hl-yellow} al que ha solicitado el `merge` por si queremos solicitar alg√∫n cambio [**antes de ser aprobado**]{.hl-yellow}

![](img/menu-pr-2.png)
---

## Pull request

Tras revisar todo y aprobarlo clickaremos en `Confirm merge`, y tras ello podremos decidir si esa rama que era paralela a la principal la queremos [**eliminar**]{.hl-yellow} o dejar visible a todos (consejo: dejar visible para tene [**trazabilidad**]{.hl-yellow} del proyecto de trabajo)

:::: columns
::: {.column width="50%"}
![](img/merge-branch.png)
:::

::: {.column width="50%"}
![](img/delete-branch.png)
:::
::::


# FRIKADAS

[**Algunos paquetes o recursos curiosos**]{style="color:#444442;"}


---

## Cosicas curiosas

### Paletas de colores

* [**{ggthemes}**]{.hl-purple}: [**temas y paletas extras**]{.hl-yellow} para ggplot (por ejemplo para **dalt√≥nicos**) <https://jrnold.github.io/ggthemes/> y <https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/>

* [**{peRReo}**]{.hl-purple}: paletas inspiradas en [**portadas de m√∫sica urbana y latina**]{.hl-yellow} <https://github.com/jbgb13/peRReo>

* [**Paletas inspiradas en el Metropolitan Museum**]{.hl-purple}: de Blake Robert Mills <https://github.com/BlakeRMills/MetBrewer/tree/main>

* [**Paletas inspiradas Taylor Swift**]{.hl-purple}:  <https://github.com/asteves/tayloRswift>

* [**Paletas inspiradas en Harry Potter**]{.hl-purple}: de Alejandro Jim√©nez <https://github.com/aljrico/harrypotter>

* [**{colorblindcheck}**]{.hl-purple}: detectar paletas de colores aptas [**dalt√≥nicos/as**]{.hl-yellow}. De Jakub Nowosad <https://github.com/Nowosad/colorblindcheck>

---

## Cosicas curiosas

### Dataviz

* [**R Graph Gallery**]{.hl-purple}: colecci√≥n de dataviz en R <https://www.r-graph-gallery.com/>

* [**{patchwork}**]{.hl-purple}: agregar y [**componer gr√°ficas**]{.hl-yellow}. De Thomas Lin Pedersen. <https://patchwork.data-imaginist.com>

* [**ggplotly**]{.hl-purple}: funci√≥n de `{plotly}`, para convertir ggplot a plotly ([**interactiva**]{.hl-yellow}) <https://www.rdocumentation.org/packages/plotly/versions/4.10.0/topics/ggplotly>.


Tras convertirlo a plotly se puede [**guardar autom√°ticamente en html**]{.hl-yellow} con <https://plotly-r.com/saving.html> y generar el [**c√≥digo del iframe responsive**]{.hl-yellow} con <https://bhaskarvk.github.io/widgetframe/articles/Using_widgetframe.html>



---

## Cosicas curiosas

### Dataviz

* [**{ggiraph}**]{.hl-purple}: gr√°ficas interactivas al [**estilo D3**]{.hl-yellow}. <https://davidgohel.github.io/ggiraph/>

* [**Aprender a usar {ggiraph}**]{.hl-purple}: para gr√°ficas interactivas al [**estilo D3**]{.hl-yellow} <https://albert-rapp.de/posts/ggplot2-tips/17_ggiraph/17_ggiraph.html> 

* [**Gr√°ficas interactivas**]{.hl-purple}: <https://www.tanyashapiro.com/interactive-visuals>

* [**{geomtextpath}**]{.hl-purple}: paquete para [**curvar el texto**]{.hl-yellow} ajust√°ndose a una gr√°fica. De Allan Cameron y Teun van den Brand. <https://allancameron.github.io/geomtextpath/>

* [**{ggstream}**]{.hl-purple}: visualizaci√≥n de [**datos en flujo**]{.hl-yellow}. De Z. Gu. <https://github.com/davidsjoberg/ggstream>

* [**{ggpattern}**]{.hl-purple}: rellenos con [**patrones geom√©tricos**]{.hl-yellow} en ggplot2. De coolbutuseless y Trevor L. Davis. <https://github.com/coolbutuseless/ggpattern>

---


## Cosicas curiosas

### Mapas

* [**{mapSpain}**]{.hl-purple}: visualizaci√≥n de [**datos en mapas de Espa√±a**]{.hl-yellow} en R. De Diego Hernang√≥mez <https://dieghernan.github.io/rpubs/mapSpain_RMadrid/#1>

* [**{rasterpic}**]{.hl-purple}: visualizaci√≥n de [**mapas con im√°genes rasterizados de fondo**]{.hl-yellow}. De Diego Hernang√≥mez. <https://dieghernan.github.io/rasterpic/>


---

## Cosicas curiosas

### Text mining

* [**Manual de text mining**]{.hl-purple}: de Julia Silge y David Robinson. Recurso: <https://tidytextmining.com>

* [**Descarga de textos libres**]{.hl-purple}: de David Robinson. Recurso: <https://github.com/ropensci/gutenbergr>

* [**An√°lisis de sentimientos de tweets**]{.hl-purple}: de Harshvardhan. Recurso: <https://www.harsh17.in/twitter-sentiments/>

### Grafos y redes

* [**{tidygraph}**]{.hl-purple}: paquete al estilo `{tidyverse}` para [**visualizar y manipular grafos**]{.hl-yellow} <https://tidygraph.data-imaginist.com/index.html>


---

## Cosicas curiosas

### Datos curiosos

* [**{fitbitr}**]{.hl-purple}: API para acceder a [**datos de pulseras fitbit**]{.hl-yellow}. De Matt Kaye <https://mrkaye97.github.io/fitbitr/index.html>

* [**{rtweet}**]{.hl-purple}: API para acceder (al menos antes) a [**Twitter**]{.hl-yellow}. De Michael W. Kearney <https://docs.ropensci.org/rtweet/>

* [**{owiDR}**]{.hl-purple}: API para acceder a datos de [**Our World in Data**]{.hl-yellow} <https://github.com/piersyork/owidR>

* [**{wordle}**]{.hl-purple}: API para acceder a [**datos de WORDLE**]{.hl-yellow}. De coolbutuseless <https://coolbutuseless.github.io/2022/01/04/wordle-v0.1.5-a-package-for-playing-and-helping-solve-wordle-puzzles/>

* [**Canciones de Taylor Swift**]{.hl-purple}: de W. Jake Thompson <https://taylor.wjakethompson.com/>

* [**{chessR}**]{.hl-purple}: API para acceder a datos de [**partidas de ajedrez**]{.hl-yellow}. De Jason Zivkovic <https://github.com/JaseZiv/chessR>


---

## Cosicas curiosas

### Informes, libros, diapositivas y webs

* [**Manual de Quarto**]{.hl-purple}: el nuevo rmarkdown, m√°s completo y sencillo para elaborar manuales, diapositivas, informes e incluso webs <https://quarto.org/docs/guide/>

* [**Shiny**]{.hl-purple}: webs interactivas con R <https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/>

### Tablas

* [**{gt}**]{.hl-purple}: tablas en R. De RStudio <https://gt.rstudio.com/>

* [**{gtExtras}**]{.hl-purple}: visualizaci√≥n de datos en tablas. De Thomas Mock. <https://jthomasmock.github.io/gtExtras/index.html>

* [**Tutorial de tablas**]{.hl-purple}: de Benjamin Nowak <https://bjnnowak.netlify.app/2021/10/04/r-beautiful-tables-with-gt-and-gtextras/>


# ¬°GRACIAS!

[**Mi mail javalv09@ucm.es, Twitter [@dadosdelaplace](https://twitter.com/DadosdeLaplace) e Instagram [@javieralvarezliebana](https://www.instagram.com/javieralvarezliebana/) para lo que quer√°is (dudas, cervezas, ...)**]{style="color:#444442;"}

